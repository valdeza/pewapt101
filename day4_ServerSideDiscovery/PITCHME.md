<!-- Automatically generated by Export-PptxToGitPITCHME.ps1
https://gist.github.com/valdeza/27845c35d14c833af63e449e5f055204 -->

<!-- Slide 1 -->
<!--[Rectangle 2]-->
Web Penetration Testing and Ethical Hacking  
Server-Side Vulnerability Discovery

<!--[TextBox 4]-->
Copyright 2014, Secure Ideas
Version 1Q14

<!--[TextBox 2]-->
Professionally Evil   
Web Application 
Penetration Testing   
101.4

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Web applications are a major point of vulnerability in organizations today. Web app holes have resulted in the theft of millions of credit cards, major financial and reputational damage for hundreds of enterprises, and even the compromise of thousands of browsing machines that visited web sites altered by attackers. 

In the next few days, you'll learn the art of exploiting web applications so you can find flaws in your enterprise's web apps before the bad guys do. Through detailed, hands-on exercises and these materials, you will be taught the four-step process for web application penetration testing. You will inject SQL into back-end databases, learning how attackers exfiltrate sensitive data. You will utilize Cross Site Scripting attacks to dominate a target infrastructure in our unique hands-on laboratory environment. And, you will explore various other web app vulnerabilities in-depth, with tried-and-true techniques for finding them using a structured testing regimen. As well as the vulnerabilities, you will learn the tools and methods of the attacker, so that you can be a powerful defender.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 2 -->
<!--[Rectangle 2]-->
Course Outline

<!--[Rectangle 3]-->
- Day 1: Attacker's View, Pen-Testing and Scoping
- Day 2: Recon & Mapping
- Day 3: Server-Side Vuln Discovery
- **Day 4: Client-Side Vuln Discovery**
- Day 5: Exploitation
- Day 6: Capture the Flag

<!--[Right Arrow 3]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
In this class, we will learn the practical art of web application penetration testing. 

On Day 1, we will examine the attacker's perspective, and learn why it is important for us to build and deploy web application with the attacker's perspective in mind. We will also cover the pieces of a penetration test and how to scope and prepare for one.  Finally, we will explore the methodology that will be covered through the rest of class.
 
During Day 2, we will step through the process that successful attackers use to exploit applications, focusing specifically on the reconnaissance and mapping stages of the process.  This will give us the foundation we need to later control the application.

On Day 3, we will build upon that foundation and start discovering the various weaknesses within the applications.  As penetration testers, we will map out the attack vectors that we are going to use against this application. These discoveries will be the basis for the exploitation phase.

On Day 4, we will continue our discovery focusing on client side components such as Flash and Java.  We will also explore the client-side scripting in use within our applications.

On Day 5, we will launch the attacks that we planned and created during the previous three sections. We will also cover the next steps for students and where they should go from here.

On Day 6, we will be performing a web application pen-test within a capture the flag event.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 3 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
- *** Cross-Site Scripting (XSS)  ***
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In the next section we are going to Cross-site scripting

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 4 -->
<!--[Rectangle 2]-->
Cross Site Scripting

<!--[Rectangle 3]-->
- Cross Site Scripting is commonly known as XSS
- It involves tricking the browser into executing code
- The browser believes that the code is part of the site and runs it in that context
- This attack targets the browser, not the server

Note:
<!--[Text Box 3]-->

<!--[Text Box 4]-->

<!--[Text Box 6]-->
Cross-Site Scripting is an attack in which an attacker injects scripting code into a web application, and the browser runs it as if it has come from the trusted site. For example, this could be a URL parameter that is read and displayed back to the user as if it were part of the application. 

The Cross-Site Scripting attack has historically been misunderstood and undervalued.  Many people fail to see the impact of the indirection.  The point is that we can leverage weaknesses in a web server or web application, and use it to attack clients of that server.  

Imagine logging into your online bank.  The banking site drops valuable session information in your browser for some time period.  Perhaps it is just a session cookie, or perhaps it is a snippet of data that includes your user ID or (hopefully not) your bank account number.  That information is stored in its own compartment in the browser, only accessible to that site.

Now imagine an attacker has the ability to access that information.  Or worse yet, imagine an attacker running code on your browser as you within the security context of the bank.  We'll get to this little twist on XSS called Cross-Site Request Forgery in the next section.

<!--[Rectangle 7]-->

<!-- SKIPPED: [Slide Number Placeholder 6]-->

---

<!-- Slide 5 -->
<!--[Rectangle 2]-->
Parts of a XSS Attack

<!--[Rectangle 3]-->
- Application
	- Running a vulnerable application
- Browser
	- Tricked into Running the code
- Attacker
	- Evil Person
- Code
	- Usually JavaScript

<!--[AutoShape 4]-->
Web
Server

<!--[Line 5]-->

<!--[AutoShape 10]-->
Browser

<!--[Freeform 43]-->

<!--[Group 1]-->

<!--[Straight Connector 35]-->

<!--[Straight Arrow Connector 37]-->

<!--[Straight Arrow Connector 41]-->

<!--[Straight Arrow Connector 44]-->

Note:
<!--[Text Box 3]-->

<!--[Text Box 4]-->

<!--[Text Box 6]-->
The four parts that make up a XSS attack are:

	- The client which is tricked into running the code.
	- The application which is leveraged into sending the code to the client.
	- The attacker who is hoping to gain from targeting the user.
	- Finally the code the attacker is hoping will run on the client.
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

<!--[Rectangle 7]-->

<!-- SKIPPED: [Slide Number Placeholder 6]-->

---

<!-- Slide 6 -->
<!--[Rectangle 20]-->

<!--[Rectangle 19]-->

<!--[Rectangle 2]-->
Same Origin Policy

<!--[Rectangle 3]-->
- According to the "same origin policy" enforced by web clients, client code from one server should not be able to access content from a different server
- Same server decided based on:
	- Host
	- Port
	- Protocol
- The browser enforces the same origin policy and blocks access to content from other servers

<!--[Straight Connector 10]-->

<!--[Text Box 13]-->
**Origin  
Server**

<!--[Text Box 13]-->
**Other  
Server**

<!--[Freeform 14]-->

<!--[Oval 75]-->
**1**

<!--[Oval 75]-->
**2**

<!--[Text Box 13]-->
**Script from 1 makes browser send request 2, getting a page in response**

<!--[Text Box 13]-->
**Client code   
requested**

<!--[Multiply 33]-->

<!--[Multiply 34]-->

<!--[TextBox 20]-->
**The script in the browser cannot alter content from 2**

<!--[Oval 75]-->
**3**

<!--[Text Box 13]-->
**Browser**

<!--[Picture 9]-->

<!--[Picture 9]-->

<!--[Picture 9]-->

Note:
<!--[Rectangle 7]-->
6

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The same origin policy is used by the browser to determine if the client side code can interact or manipulate the content.  It states that only content from the same server is accessible to the code.  The same origin is determined by the hostname, port and protocol.  The hostname is used instead of the IP due to sites that use multiple servers for load balancing.

---

<!-- Slide 7 -->
<!--[Rectangle 19]-->

<!--[Rectangle 18]-->

<!--[Title 1]-->
# Why Same Origin Policy?


<!--[Content Placeholder 7]-->
- The same origin policy was implemented to provide security
- Imagine if any client content could interact with any site's content
	- Cross site scripting attacks would be devastating
	- You surf to my evil site. I push back a script. that script has your browser retrieve your bank records.
	- Policy prevents script from reading the bank information
- Browsers were forced to provide some type of control
	- There are ways a pen tester can bypass this, but let's not get ahead of ourselves

<!--[Straight Connector 10]-->

<!--[Text Box 13]-->
**James' Evil   
Server**

<!--[Text Box 13]-->
**Bank  
Web   
Server**

<!--[Freeform 14]-->

<!--[Oval 75]-->
**1**

<!--[Oval 75]-->
**2**

<!--[Text Box 13]-->
**Script from Ed retrieves bank data**

<!--[Text Box 13]-->
**Malicious   
JavaScript   
loaded**

<!--[Multiply 16]-->

<!--[Multiply 17]-->

<!--[TextBox 20]-->
**The script in the   
browser cannot access   
the bank data**

<!--[Oval 75]-->
**3**

<!--[Picture 9]-->

<!--[Picture 9]-->

<!--[Picture 9]-->

Note:
<!--[Rectangle 7]-->
7

<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Same origin policy was a requirement to provide security around content.  Imagine if you could write code that could interact with content from any site?  Web sites could be defaced within the browser, cookies could be stolen and forms could be changed to submit where ever the attacker wanted them too.

As you will see later in class, these attacks and others are all possible with XSS, but if same origin was not enforced, they would become trivial to carry out by simply sending an e-mail that contained JavaScript code.

---

<!-- Slide 8 -->
<!--[Title 1]-->
# Enforcing the Same Origin Policy


<!--[Group 38]-->

<!--[Rectangle 4]-->
- Suppose a browser fetches a script by accessing this URL:  
http://www.PEWAPT.org/about/info.php
- When it runs the script, the browser allows the script to issue further HTTP requests
- But, will the script running in the browser be able to access the responses?  It depends.

Note:
<!--[Rectangle 7]-->
8

<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This chart shows the various rules that affect the same origin policy.  As you can see from this chart, the same origin policy restricts access based on three pieces of information.  These pieces are the hostname, the protocol and the port number.  This means that when a JavaScript snippet or file is loaded by a browser, the code can only affect content that is served from the same origin.

As you can see from the chart, by changing the port or the host, same origin blocks the access.  Protocol changes also violate the same origin policy, which is one reason so many sites support both http and https for their content.

---

<!-- Slide 9 -->
<!--[Rectangle 2]-->
Discovering XSS

<!--[Rectangle 3]-->
- Many are simple to find
	- Using only a browser
- These are low hanging  
 fruit
- Find input fields
- Input XSS code
	- Simplest is:
		- <SCRIPT>alert("XSS")</SCRIPT>

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Now we are going to discuss finding these flaws in web applications.  Quite a few of the flaws are simple to find.  Using only a browser and pushing JavaScript into various input fields, the attacker can discover most of the low hanging fruit within the application. 

The simplest method is to just enter the code "<SCRIPT>alert("XSS")</SCRIPT>" into any input fields that will accept it. Once the form is submitted, look for the pop up shown in the screenshot.  To make this even easier, based on the mapping we discussed yesterday, the attacker should focus on fields that are displayed back to the user.  But keep in mind that many inputs are used in the application and then possibly displayed later in the application flow.  For example, a form that allows a user to update their information may not display that information back directly but this information is stored and displayed in "Account" sections of the site or even in functions that allow other users to view a specific profile.  This type of flaw lets you attack others directly.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 10 -->
<!--[Title 1]-->
# XSS and Parameters


<!--[Content Placeholder 2]-->
- XSS is found in parameters that are used in display
	- Either immediately or later
- Each parameter found to be used in display should be tested
	- Fuzzing each in turn
- Mapping built a list of interesting parameters
	- Work from this list

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we move to discover XSS flaws within the tested application, we need to work from what we found in mapping.  We need to look at each of the parameters which are then used in the display.  We should fuzz each of these parameters during our testing.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 11 -->
<!--[Rectangle 2]-->
Filtering

<!--[Rectangle 3]-->
- Some sites have gotten "tricky"
- They have started filtering input
- Two types of filtering are common
- Whitelists
	- Filtering based on "known goods"
	- Better security
- Blacklists
	- Filtering based on "known bads"
	- Easier to bypass

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As XSS has become more known through the developer communities, applications have started to come with filtering techniques that try to protect the application and its users from injection attacks. They try to filter the input before using it within the application or display.  Two types of filtering are being used.  The first is whitelisting and the second is blacklisting. These differ in their way of determining what is malicious.  But time is on the attacker's side.  While the application has to detect malicious code every time input is accepted, the attacker only has to discover one way to bypass the filter.

There are two ways to validate input, white-listing and black-listing.

White-listing: the developer specifies what should be allowed in a given field.  This is the recommended approach.

Black-listing: the developer identifies known bad characters and the system either filters them out or blocks the request altogether.  

Both approaches have their own challenges.  White-listing can be more work because the developer must be exact in the specifications of each field.  For dates and times this is seldom an issue.  For blobs and text fields this is much more problematic. In addition, white-listing still requires a knowledge of bad characters so they don't accidentally find their way into the whitelist.

The problem with black-listing is that one never has comprehensive knowledge of all attacks. As attackers, we can be infinitely creative. Developers can block known bad characters, but what about other characters? What about different encodings?  Can all versions of bad characters be filtered?  Consistently?

The most effective solution is usually a combination of both white- and black-listing.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 12 -->
<!--[Rectangle 2]-->
Bypassing Filters

<!--[Rectangle 3]-->
- Many ways are available to bypass filters
	- Encodings such as Unicode and hex
	- Others forms of scripting such as VBScript
	- Scripting within tags other than <script>
- We will explore this in detail during exploitation on day 5
- Excellent resource:
	- https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Many different techniques are available to bypass the filtering happening within an application.  For example, using different encodings or functions such as the hex encoding or the fromCharCode function.  Taking the example <SCRIPT>alert("XSS")</SCRIPT> and hex encoding it and making it part of an image tag, we get <img src=&#x3C;&#x53;&#x43;&#x52;&#x49;&#x50;&#x54;&#x3E;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x22;&#x58;&#x53;&#x53;&#x22;&#x29;&#x3C;&#x2F;&#x53;&#x43;&#x52;&#x49;&#x50;&#x54;&#x3E;>. 

Also using tags such as the IMG tag above, DIV and styles, we can bypass filtering that looks for the traditional <SCRIPT> tags.

The site https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet is an excellent resource for the various bypass methods.  They list various means and which browsers support that particular bypass.  As we will see tomorrow, most of the advanced tools use this list in their attacks.  So should you!

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 13 -->
<!--[Rectangle 2]-->
Types of XSS

<!--[Rectangle 3]-->
- Two types of XSS flaws
	- Reflected
		- Easiest to test
		- Place script in URL
	- Persistent
		- Requires attacker to input script
		- Then view resulting page
	- DOM-Based
		- Arbitrary parameters used by client-side code

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
There are two types of XSS that web application penetration testers are concerned about.  These are "reflection" and "persistent." The other form of XSS, Local DOM-based, is an attack against client software, not specifically web applications.

XSS reflection attacks are simple.  Place <script>alert('XSS')</script> in the URL or in a POST to a site and the script is returned immediately on the page.  Because of the simple and immediate nature of XSS reflection attacks, automated tools can identify this form of XSS simply and with a great deal of confidence.

Reflection is commonly used in linked XSS, such as IM messages or e-mail messages saying "Click here to come see my pictures".

Persistent XSS uses a web site's message-board features to place scripts in other users' browsers.  This is commonly used in guest books, classified ads, and other areas where user posting is allowed and encouraged.  

DOM-based is where the client-side code uses the original request unsafely.

Successful exploitation results in an attacker's script having access to the web site as that user.


<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 14 -->
<!--[Title 1]-->
# Reflected XSS


<!--[Content Placeholder 2]-->
- Reflected XSS payloads are in the request
	- The application uses the payload immediately
- The link is sent to   
the victim
	- Via email or other delivery method

<!--[Picture 6]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This page intentionally left blank.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 15 -->
<!--[Title 1]-->
# Persistent XSS


<!--[Content Placeholder 2]-->
- Persistent XSS is based on the application storing the payload
	- For later use
- Common examples are:
	- Message boards
	- Account settings
- It attacks a wider range of people
	- Due to the stored nature of the attack

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Persistent XSS flaws are based on the application storing the payload.  An attacker would inject it via a request such as a forum posting.  The application accepts this input and stores it.  Then later, a victim browses to the page that uses that stored input.  The application sends it as part of the page.  This type of attack targets a wider range of people due to the fact that it is displayed across the application.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 16 -->
<!--[Title 1]-->
# DOM-based XSS


<!--[Content Placeholder 2]-->
- DOM-based XSS (D-XSS) is an interesting sub-type
	- It is a reflected attack but slightly changed
- The application does not return the attack
	- It returns client-side code that reads the URL
	- The client uses the URL within the DOM
- Commonly found due to third-party services
	- Analytics or mash-up type systems

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Another type of XSS attack that is useful during our testing is the DOM-based XSS flaw.  This type of attack is really a sub-type of the reflected attack.  This main difference is that the application does not reflect our payload.  It has within it client-side code that reads the URL or other sources and makes use of the source within the Document Object Model (DOM).  For example, an application can read the URL to fill in a form field.  If the application performs this action on the client-side, the application can be vulnerable to this flaw.

We commonly find this flaw within mash-up or analytic type systems.  This is due to their need to use the URL or other information within their functions.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 17 -->
<!--[Title 1]-->
# DOM-based XSS Explanation


<!--[Content Placeholder 2]-->
- D-XSS uses the client features
	- Not a flaw directly in the server application
- The victim makes the request
	- A GET request typically
- The web page uses values from the URL
	- Makes use of these values within scripting
- The server application doesn't *reflect* the payload
	- The browser actually executes the attack

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
DOM-based XSS (D-XSS) is not exactly a flaw in the server application; meaning that this application does not accept the input and use it within the response.  This is important to understand because many developers misunderstand this and don't see why the filtering or encoding they are attempting on the server won't fix this issue.

The way that D-XSS works is that a user makes a request of the application.  While GETs are traditionally where we find this flaw, many other sources can be exploited.  The web page, specifically any client-side functionality, makes use of these values within its processing.  When this happens, the browser doesn't realize the attack is there, the code is just treated as part of the page.  This is why we can say that the application does not reflect the attack from the server application; the browser executes it from within the DOM.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 18 -->
<!--[Rectangle 2]-->
Persistent (Admin)

<!--[Rectangle 3]-->
- Sub-type of the persistent flaw
- User submitted content requires approval before being posted
- Admin users review content before posting and approve the content
	- This usually uses a web interface
- Guarantees higher privilege user is the first to view the attack

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Sometimes web developers attempt to protect their users by sending all user-submitted content into a queue, which administrators review and approve for public consumption. This is excellent for attackers, since it means that when they find an XSS vulnerability, they are guaranteed that an administrative user will view it.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 19 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
- *** Cross-Site Scripting Exercise***
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next exercise will use a reflective XSS attack against PHPMyAdmin.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 20 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
- *** Cross-Site Scripting Discovery***
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next exercise will use a reflective XSS attack against PHPMyAdmin.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 21 -->
<!--[Rectangle 2]-->
Tools for Discovering   
XSS Flaws

<!--[Rectangle 3]-->
- Multiple tools are available for finding the flaws
- These tools typically either intercept the requests and allow us to modify them, or they insert the attacks within the inputs for us
- We are going to review some of the tools now
	- Web Developer Extension
	- Live HTTP Headers Extension
	- TamperData
	- XSS Me
	- GreaseMonkey
	- Burp Suite

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Multiple tools are available for testing XSS flaws.  These tools typically intercept the requests and allow us to mangle them, but some actually include the attack strings themselves.

Most XSS tools are plug-ins for Firefox.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 22 -->
<!--[Rectangle 2]-->
Web Developer Extension

<!--[Rectangle 3]-->
- Series of tools built into a single extension
- Its main focus is web developers checking their application
- Focus on two features of interest to security testing
	- Convert Form Method
	- Edit HTML

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Menu Items for Web Developer Extensions:
DISABLE - disable java, JavaScript, redirects, and others.
COOKIES - disable, clear, delete, view and add cookies
CSS - view, add, edit CSS, and more.
 FORMS - view form info/details/passwords, convert and edit form fields
IMAGES - manipulate how images are displayed
INFORMATION - marks up page to show layout, etc.

MISC. - *show hidden fields, comments, edit HTML and other goodies!*

OUTLINE - draw outlines around various elements in the page
RESIZE - change the browser window size
TOOLS - all sorts of validation routines (HTML, CSS, links, WAI, etc.)
VIEW SOURCE -  view document/frame source and "view generated source"
OPTIONS - configure toolset, Help, About

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 23 -->
<!--[Rectangle 2]-->
Web Developer Functions

<!--[Rectangle 3]-->
- Convert method function
	- Allows us to change which method the forms use
	- Simple method to test method interchange
- Edit HTML function
	- Allows LIVE editing of the HTML
	- Don't like a form field restriction?
	- Want to make that hidden field visible?

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Implementing the same code twice is a pain.  Many developers will simply have the handlePOST() subroutine call to handleGET() or vice-versa, so that all requests are handled the same without rewriting the code. This is not always the case, however.  At times, we find that one implementation has a flaw or two in the processing.

The Edit HTML function in the Web Developer Extension allows you to edit the document that is visible in the browser.  You can use this to remove the code that restricts input fields and turn hidden fields visible.  Once visible, you can use them as if they were text input fields.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 24 -->
<!--[Title 1]-->
# TamperData


<!--[Content Placeholder 2]-->
- As with SQL injection, TamperData is a great tool to find XSS flaws
- TamperData provides a built in list of XSS attacks
	- Not as extensive a list as the SQL injection ones
- Simple to use, and allows for us to test for XSS and SQL injection within the same tool

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we mentioned before, TamperData intercepts the requests and allows us to mangle them to test for XSS flaws.  It includes a collection of XSS attack strings but this list is not anywhere near as extensive as the SQL injection list included.  The nice feature is that we are able to test for SQL injection and XSS within the same tool.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 25 -->
<!--[Picture 4]-->

<!--[Rectangle 2]-->
GreaseMonkey

<!--[Rectangle 3]-->
- GreaseMonkey is an active browsing component
	- This means that it dynamically add scripts to  
a page
	- Sounds like XSS doesn't it?
- Lots of scripts already available
- Some of the interesting ones:
	- XSS Assistant

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
GreaseMonkey is a Firefox extension which allows the user to install scripts in web pages.  This is done on the client side using the GreaseMonkey extension.  These scripts are not injected using XSS, but run within the GreaseMonkey extension.  This allows GreaseMonkey to run on any application.

While there are hundreds of user submitted GreaseMonkey scripts, and you can add your own, the one that is of the most interest to us right now is XSS Assistant.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 26 -->
<!--[Rectangle 2]-->
XSS Assistant

<!--[Rectangle 3]-->
- Available at   
http://www.whiteacid.org/
- It provides a menu that allows us to target forms
- Includes the XSS Cheatsheet from RSnake
- Drop downs to select attack vector

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
XSS Assistant is my personal favorite tools for playing with XSS attacks.  It makes use of the previously mentioned XSS cheat sheet and provides a floating set of buttons to perform various attacks.

In the above screen shot you see the floating buttons for the attacks.  The orange and white is placed throughout the display where ever a form is in the document.  By right clicking on the box, the blue floating buttons appear allowing the attacker to control the forms of injection used. You are able to select which XSS cheatsheet you would like to use, and then the vector of attack.  This is where you try the various encodings and "cheats" we talked about earlier.  You are then able to select the form field you would like to insert the code into, with a special one call GLOBAL which injects in to all of the inputs at once.  You can then either submit the form or generate a proof of concept link to e-mail to your target.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 27 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
- *** Persistent XSS Exercise***
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise we will attack PHPBB with a persistent XSS attack.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 28 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
- *** Cross-Site Request Forgery (CSRF)***
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover CSRF.  We will walk through how the attack works and the methods used to find these flaws.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 29 -->
<!--[Rectangle 1028]-->
Cross-Site Request Forgery

<!--[Rectangle 1029]-->
- Cross-Site Request Forgery (CSRF) is an attack that leverages trust
	- The trust a web site has in the user (or at least that user's browser)
- CSRF takes advantage of an active session a browser has with the target site
	- The attack is possible due to predictable parameters on sensitive transactions
	- An example money transfer transaction might have two parameters: Destination Account and an Amount
		- Yes, there is also likely a SessionID, but that is automatically passed by the browser to the server, and the attacker doesn't need to know it
	- Are valid parameters for the transaction predictable and/or controllable by the attacker?

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Cross Site Request Forgery is (CSRF) is similar to XSS, but it doesn't require that the attacker inject code into a web application. CSRF simply leverages the fact that web servers trust authenticated users, and it is possible to pass unauthorized commands from client to server without the user's knowledge. These commands are then executed on the server with the client's authenticated user privileges.

For example, imagine that a user logs into her online bank account. This bank stores authentication information in a cookie which is valid until the session times out or the user logs out. Let's say we create a web site which contains a script that will attempt to transfer money from the user's bank account to our own offshore account.  We post content to a web site containing a image reference to this page. If she opens the page while logged into her bank's site, then the script will execute with her privileges and her money will be transferred to our account without her explicit authorization. 

This type of attack can leverage many different kinds of privilege. For example, consider the scenario where the target of this attack is a network administrator, who logs into the CiscoWorks web interface.  There are a number of ways that web application developers can limit the effectiveness of CSRF attacks- for example, by using tokens in submission forms which ensure that requests have actually come from the web form. However, improving CSRF resistance is not always a high priority for web developers, because typically CSRF compromise doesn't directly impact the corporation-- at least not as immediately as with SQL Injection, Command Injection, or Buffer Overflow exploits.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 30 -->
<!--[Rectangle 2]-->
CSRF Attack Walk-through

<!--[Rectangle 3]-->
- Attacker determines a link to initiate a transaction that uses predictable parameters
- Attacker posts this link on a site he controls
	- This site could just be a MySpace page or similar
	- Or the attacker could force the users to the site through DNS poisoning
- User logs into the application normally
- While the user is still logged in, they browse the link from the attacker
- This link could be 
	- An Image tag
	- An IFRAME
	- CSS or JavaScript import
	- XMLHTTP
- This initiates a transaction as the victim
- The application isn't aware that the user didn't mean to submit the transaction

Note:
<!--[Text Box 3]-->

<!--[Text Box 4]-->

<!--[Text Box 6]-->
Cross-Site Request Forgery covers scripting requests in general, but the most concerning types could easily be called Script-Based Web Session Hijacking.  Take the CiscoWorks example from the previous slide for example.

Imagine that a CiscoWorks administrator, Bob, is logged into CiscoWorks web console while doing other work. CiscoWorks administrators commonly log into the application and stay connected throughout the day. We insert a malicious link into a comment on a popular IT web site.  When Bob visits the popular website and views the comments, his browser is directed to request the link, which executes functions within the CiscoWorks server.  At this point, the attacker could be requesting changes to the network, potentially opening up holes for later attacks.

<!--[Rectangle 7]-->

<!-- SKIPPED: [Slide Number Placeholder 6]-->

---

<!-- Slide 31 -->
<!--[Line 7]-->

<!--[Title 1]-->
# CSRF Walk-through (1)


<!--[Line 7]-->

<!--[AutoShape 14]-->
****
****
****
**Internet**
****
****

<!--[Group 34]-->

<!--[Text Box 64]-->
**Pen Tester**

<!--[Object 2]-->

<!--[Text Box 67]-->
**Target   
Web Application**

<!--[Text Box 64]-->
**Pen  
Tester's  
Server**

<!--[Object 3]-->

<!--[Rectangle 36]-->

<!--[Freeform 38]-->

<!--[Freeform 106]-->

<!--[Freeform 39]-->

<!--[Freeform 40]-->

<!--[Freeform 42]-->

<!--[Freeform 43]-->

<!--[Text Box 51]-->
**Pen-tester builds a web page that contains a request to the vulnerable transaction**

<!--[Oval 132]-->
**2**

<!--[Text Box 51]-->
**Pen-tester finds a transaction that contains predictable parameters**

<!--[Oval 132]-->
**1**

<!--[AutoShape 15]-->
****
**Target**
**Network**

<!--[Text Box 16]-->
**Client**

<!--[Object 5]-->

<!--[Text Box 51]-->
**Pen-tester places web page on a server he controls, to represent a trusted, third-party server**

<!--[Freeform 1080]-->

<!--[Oval 132]-->
**3**

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
1. Pen-tester finds a transaction that contains predictable parameters
2. Pen-tester builds a web page that contains a request to the vulnerable transaction
3. Pen-tester places web page on a server he controls, to represent a trusted, third-party server

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 32 -->
<!--[Line 7]-->

<!--[Title 1]-->
# CSRF Walk-through (2)


<!--[Line 7]-->

<!--[AutoShape 14]-->
****
****
****
**Internet**
****
****

<!--[Group 34]-->

<!--[Text Box 64]-->
**Pen Tester**

<!--[Object 2]-->

<!--[Text Box 67]-->
**Target   
Web Application**

<!--[Text Box 64]-->
**Pen  
Tester's  
Server**

<!--[Object 3]-->

<!--[Rectangle 36]-->

<!--[Freeform 38]-->

<!--[Freeform 39]-->

<!--[Freeform 40]-->

<!--[Freeform 42]-->

<!--[Freeform 43]-->

<!--[Text Box 51]-->
**Content from pen tester****'s web page makes user's browser send request to the vulnerable application to process a transaction with the attacker's inserted parameters**

<!--[AutoShape 15]-->
****
**Target**
**Network**

<!--[Text Box 16]-->
**Client**

<!--[Object 5]-->

<!--[Text Box 51]-->
**While having an open session on the target web app, user browses to pen-tester****'s web page**

<!--[Freeform 106]-->

<!--[Text Box 51]-->
**Vulnerable application processes pen tester generated transaction**

<!--[Oval 132]-->
**6**

<!--[Freeform 1079]-->

<!--[Oval 132]-->
**4**

<!--[Oval 132]-->
**5**

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
4.    While having an open session on the target web app, user browses to pen-tester's web page
5.    Content from pen tester's web page makes user's browser send request to the vulnerable application to process a transaction with the attacker's inserted parameters
6.    Vulnerable application processes pen tester generated transaction

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 33 -->
<!--[Rectangle 2]-->
Detecting CSRF

<!--[Rectangle 3]-->
- Currently there are no stable tools to detect CSRF flaws
	- Some of the scanners try with experimental plug-ins
	- Most find transactions that contain predictable parameters
		- Tester is then prompted to test it manually
- Four Steps
	- Review the app logic
	- Find functions that:
		- Perform a sensitive action
		- Parameters predictable
	- Create a page with the request
	- Access the page while logged in

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
CSRF is much more difficult to detect than XSS, because it relies upon pages that are not part of the server application. At this time, CSRF vulnerability is not detected by the automated scanners and therefore requires manual discovery work.

There is a four step process for finding CSRF flaws in the application.  First review the application logic.  You can use the application map created earlier in the attack.  Find pages that perform a sensitive action and have predictable parameters.  Then create a HTML document that contains a tag referring to the sensitive page.  Use an IMG or IFRAME tag.  Now once you have logged into the application, access the created document.  Now verify with the application if the function actually ran.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 34 -->
<!--[Title 1]-->
# Attacking XSRF


<!--[Content Placeholder 2]-->
- Exploiting XSRF involves creating web pages that hold the attack link
	- IMG or IFRAME tags are commonly used
- The attacker then needs to get the victim to view the page while they have an active session
- While creating this page sounds simple, typically we need to test multiple vulnerabilities

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
XSRF exploitation has always been a very manual process.  Once the tester finds a flaw in the web application, they must build a web page that contains a link to the vulnerable transaction.  This typically takes the form of an <img> or <iframe> tag but can use any HTML or script that will fire the link without user interaction.

The attacker then needs to get the victim to browse to the exploit page while they have an active session.  During some tests this is done by tricking a client into browsing to the page, in others the tester will work with their point of contact to validate the page or will exercise the exploit themselves.

After the victim browses to the page, the tester then needs to go verify that the attack ran.

While the creation of this page sounds simple, keep in mind that the tester typically has to test multiple vulnerabilities.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 35 -->
<!--[Title 1]-->
# MonkeyFist


<!--[Content Placeholder 2]-->
- Nathan Hamiel created MonkeyFist to automate XSRF exploitation
	- http://hexsec.com/labs
- MonkeyFist is a python application that hosts XSRF exploits for testing
	- It includes a simple HTTP server
- It uses an XML file to configure the attacks
- Attacks are chosen based on the referer header
	- Multiple attack options are available

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
MonkeyFist by Nathan Hamiel is the answer to testing multiple XSRF flaws at once.  It is a simple python application that hosts the XSRF exploit for the tester to use via the built-in HTTP server.  

MonkeyFist is configured by simply creating an XML payload and as the victims are forced over to it, the referer header is used to determine which attack is run.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 36 -->
<!--[Title 1]-->
# MonkeyFist Attack: GET/POST


<!--[Rectangle 3]-->
<PAYLOAD n="1">
	<SITE l="**www.target.tld**">
		<METHOD>**GET**</METHOD>
		<TARGET>**http://www.google.com/search?q=InGuardians**  
		</TARGET>		
	</SITE>
</PAYLOAD>
<PAYLOAD n="2">
	<SITE l="**www.secureideas.com**">
		<METHOD>**POST**</METHOD>
		<TARGET>**http://www.target.tld/update.php**</TARGET>
		<HEADER>**User-Agent**</HEADER>
		<HEADVAL>**Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)**</HEADVAL>
		<POSTVAR>**foo**</POSTVAR>
		<POSTVAL>**bar**</POSTVAL>
		</SITE>
	</PAYLOAD>

<!--[TextBox 3]-->
URL of the XSRF vulnerability

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Variables used in the POST request

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Value of the Referer header

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
On this slide we have the payloads for a GET attack and a POST attack.  As you can see, the Payload is assigned a number and then contains a site tag which holds the referer information related to this exploit.  The target value is where we want to access within the exploit.  For example, the first payload will cause the victim's browser to retrieve the search results from Google for the string "InGuardians".

In the second payload, the exploit will not only have the victim browse to the update.php file on target.tld, it will set the headers of the request to include a specific user-agent and a POST variable of **foo**.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 37 -->
<!--[Title 1]-->
# MonkeyFist Attack: PAGE


<!--[Content Placeholder 2]-->
- The PAGE option will attack the XSRF vulnerability
	- Then redirects to another page using a META Refresh

<!--[Rectangle 3]-->
<PAYLOAD n="3">
	<SITE l="**counterhack.net**">
		<METHOD>**PAGE**</METHOD>
		<ATTACKTYPE>**GET**</ATTACKTYPE>
		<TARGET>**http://secureideas.com/test.php**</TARGET>
		<DESTINATION>**http://www.youtube.com/watch?v=dTQ63uppjlM**</DESTINATION>
	</SITE>
</PAYLOAD>

<!--[TextBox 3]-->
Value of the Referer header

<!--[Left Arrow 4]-->

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Will the generated page use GET or POST

<!--[TextBox 3]-->
Where to go after attacking

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The PAGE attack is more subtle than the previous two.  It sends a web page to the browser that first runs the transaction that is vulnerable and then uses a META REFRESH to send the victim to another site.  In this example, it will first access the test.php file on inguardians.com and then refresh to a video of Ed Skoudis.  This is great for testing since we can place a link somewhere that says "Check out this video" and when the user clicks it, they will see a *great* video, but first the XSRF flaw will be exploited.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 38 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
- *** Session Flaws***
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Next we will discuss session flaws.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 39 -->
<!--[Title 1]-->
# Session Flaws


<!--[Content Placeholder 2]-->
- Session state is a key point within web applications
- Session flaws can allow for various attacks
	- Session hijacking from predictable session IDs
	- Session fixation which is covered next

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session state is a critical point within most applications.  If we determine that flaws exist here, we are able to perform hijacking of a session.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 40 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
- *** Session Fixation***
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session fixation is a common attack vector against session state.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 41 -->
<!--[Title 1]-->
# Session Fixation


<!--[Content Placeholder 2]-->
- Session fixation allows for us to control a user's session ID
- The basic cause of the flaw is not changing the session ID after a user authenticates
- We provide a link to a user
	- The link includes the session ID
- When the user clicks and authenticates
	- We are able to use the session ID also

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session fixation allows us to control what session ID a user is assigned instead of attempting to predict it.  The flaw is caused because the application assigns a session ID before authentication.  Then when the user authenticates, the application continues to make use of the same session token.  The attacker is then able to receive a session ID from an application and send it to the victim.  When the victim clicks the link and authenticates, the attacker is able to then access the site using the same ID.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 42 -->
<!--[Title 1]-->
# Discovering Session Fixation


<!--[Content Placeholder 2]-->
- Session fixation is a flaw that is simple to find
	- Often discovered during mapping
- Look for session identifiers sent before authentication
	- Within the interception proxy
- After authentication, compare the ID
	- Did they change after auth or not?

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Discovering session fixation is actually quite easy.  During the mapping phase of the testing, we should be looking for session tokens.  We would then compare the ones we received before authentication to the ones in use after authentication.  If the tokens are still being used, then session fixation may be possible.  

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 43 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  ***AJAX***
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover AJAX, which is the most common interface for the Web 2.0 revolution.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 44 -->
<!--[Rectangle 2]-->
AJAX

<!--[Rectangle 3]-->
- Asynchronous JavaScript and XML is the basis of AJAX
- The XMLHttpRequest object we covered in PEWAPT101.1 is the heart of AJAX
- Used to build "thick" clients on the web
- Applications are designed to make requests, without user interaction

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
AJAX is the technology used to enable asynchronous communication between your browser and the web server. In old-style web sites, when you click a link, the client has to send a request all the way up the server, the server processes the request and then replies. When the browser gets the entire reply, it redraws the entire screen. 

With AJAX, the JavaScript creates XMLHTTP objects. Those objects can make requests and receive responses asynchronously, updating the display as responses are received. For example, consider Google Maps. When you go to Google Maps and you search for something and slide the map, your browser uses AJAX to make calls back and forth to the server to retrieve the images that make the map. In this way, the map changes dynamically, but the remainder of the page is static and does not need to be redrawn with each change.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 45 -->
<!--[Title 1]-->
# Mash-ups


<!--[Content Placeholder 2]-->
- One popular "feature" of AJAX enabled sites is building mash-ups
	- Combining two or more applications to provide a larger feature set
- Same Origin causes issues for these types of sites
- It is very common for applications to build proxy capabilities to enable mash-ups

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
One of the more popular features of web 2.0 web sites are mash-ups.  This is where an application combines two or more other sites into a widget or feature of their site.  The same origin policy we discussed earlier in class cause issues for these types of applications.  Because of this, many mash-up applications include proxy capabilities to remove this restriction.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 46 -->
<!--[Rectangle 2]-->
Same Origin

<!--[Rectangle 3]-->
- AJAX does not change the same origin policy
- Same as with "normal" JavaScript
- Can only access data from:
	- Same host
	- Same protocol
	- Same port
- Based on the HTML file location that includes the script

<!--[Straight Connector 10]-->

<!--[Text Box 13]-->
**Ed's Evil   
Server**

<!--[Text Box 13]-->
**Bank  
Web   
Server**

<!--[Freeform 14]-->

<!--[Oval 75]-->
**1**

<!--[Oval 75]-->
**2**

<!--[Text Box 13]-->
**Script from Ed retrieves bank data**

<!--[Multiply 10]-->

<!--[Multiply 11]-->

<!--[TextBox 20]-->
**The script in the   
browser cannot access   
the bank data**

<!--[Oval 75]-->
**3**

<!--[Picture 20]-->

<!--[Picture 21]-->

<!--[Picture 22]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The Same Origin policy is still in effect for AJAX applications.  This means that the JavaScript can only access data from the same origin that the original JavaScript came from.  When the XMLHttpRequest object is created, it can only make requests back to the server the script came from.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 47 -->
<!--[Title 1]-->
# Mash-up Proxy Features


<!--[Content Placeholder 2]-->
- Typically they use a proxy built into their application
- This proxy is part of the application
	- Retrieving pages through it bypasses same origin restrictions

<!--[Picture 22]-->

<!--[Straight Connector 10]-->

<!--[Text Box 13]-->
**Client**

<!--[Picture 22]-->

<!--[Picture 22]-->

<!--[Picture 22]-->

<!--[Text Box 13]-->
**Mash-up Application**

<!--[Text Box 13]-->
**Facebook**

<!--[Text Box 13]-->
**Google Maps**

<!--[Straight Connector 10]-->

<!--[Straight Connector 10]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
These applications will build the proxy capabilities right inside the application.  It receives the requests from the client code and retrieves the site desired.  When the client code from both sites is returned to the user, it appears to be coming from the mash-up application allowing the bypass of same origin restrictions.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 48 -->
<!--[Title 1]-->
# Mash-up Proxy Issues


<!--[Content Placeholder 2]-->
- The main issue is control of the URLs to proxy
- The proxies commonly use GET or POST parameters to call the back-end site
- If we can change this, we can perform different attacks
	- Proxy to attack or browse other sites
	- Instruct the proxy to load malicious JavaScript
- The application may use a check string to prevent this attack type

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The main issue is control of this URL being used by the proxy.  If we can change the URL parameter we can do quite a bit.  This parameter is commonly part of a GET or POST request and we can abuse it to either browse to other sites, possibly intranet applications we cannot access directly, or retrieve malicious JavaScript for an XSS attack.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 49 -->
<!--[Rectangle 2]-->
AJAX Attack Surface

<!--[Rectangle 3]-->
- The AJAX attack surface is larger than "normal" applications
	- Large amounts of client side code
	- Business logic is client side
- AJAX does not add "new" attacks
	- But it does typically add new input points to an application
- Typical attacks work
	- SQL injection
	- XSS
- AJAX applications are also architected towards CSRF
	- Functionality called directly by client code

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
All of the typical attacks work against the AJAX interface.  But it is made easier by the large amounts of client side code that performs business logic and has to understand the application flow.  This makes the application flow quite clear to a knowledgeable attacker.  The attacker can even access business logic in an order not expected by the application.  An example of this would be a shopping cart that allowed an attacker to use the credit authorization before adding items to the cart.  Potentially this would allow them to purchase items with an authorization for zero dollars.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 50 -->
<!--[Title 1]-->
# AJAX Mapping


<!--[Content Placeholder 2]-->
- Mapping of an AJAX web site is harder
- Most spidering tools cannot handle client logic
- Difficulty is caused by links being dynamically generated
	- Requires more manual work

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Mapping AJAX-ified applications is more difficult in a lot of cases.  This is because so much of the application functionality is called via client-side code or being dynamically generated.  The tools we use most were not designed to parse and evaluate this code.  This of course causes the tester to manually walk the site to ensure that all of the target functionality is added to the site map being worked from.  

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 51 -->
<!--[Rectangle 2]-->
AJAX Discovery

<!--[Rectangle 3]-->
- Many tools have issues with AJAX
	- They weren't designed to parse client side logic
- Some interception proxies can deal beyond just proxying
	- WebScarab
	- Burp
- There are also some AJAX specific tools
	- Ratproxy

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
AJAX discovery depends greatly on the tester's ability to intercept all of the requests the application makes.  Using the tools we have covered already, such as WebScarab, will allow you to intercept the calls.  You can then catalog each of the requests and its parameters to determine if any of the vulnerabilities we have covered are in the application.

While there are few AJAX specific tools, one open source tool that is interesting is ratproxy.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 52 -->
<!--[Title 1]-->
# AJAX Exploitation


<!--[Content Placeholder 2]-->
- Exploitation itself is not more difficult for AJAX applications
	- As long as we understand how the flaw fits within the application
- Exploitation has to take into account the discussed problems
	- Tools that require the ability to parse the site and can't
- Most tools can handle the requests
	- But we do typically have to manually prime them

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Exploitation of AJAX applications typically do not have any more difficulty than non-AJAX applications.  The problems we run into are caused by the previously discussed issues.  For example, if the tool is not able to discovery the flaws, it can't seed its exploitation functions.

The easiest way around this is for us to manually seed the flaws to the tools.  For example, SQLMap accepts parameters to attack as part of its command-line arguments.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 53 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	- *** Logic Attacks***
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Logic attacks abuse the client-side nature of AJAX applications.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 54 -->
<!--[Rectangle 2]-->
Logic Attacks

<!--[Rectangle 3]-->
- Client controls code execution
- Business logic is included in the client code
	- Calls functionality on the server
- Attacker manually calls functions in a different order
- Application processes the transaction incorrectly
- Logic attacks are difficult for automated tools to find

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
AJAX and Web 2.0 are a great thing for logical attackers!  This is due to the business logic being sent and executing on the client side.  A tester is able to walk through a successful transaction.  By intercepting each step in the process, the tester can examine each call throughout the process looking for the application flow.  By manually calling portions of the transaction before the application expected it to be, the tester can find vulnerabilities.  

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 55 -->
<!--[Title 1]-->
# Logic Attack Example


<!--[Content Placeholder 3]-->

<!--[Content Placeholder 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
For example, if you have a shopping cart that follows the below process:

	1. Add item to cart
	2. Total cost
	3. Authorize card
	4. Check out

Since the application stores the state of each step, the tester could call the authorize card before the add item.  This would cause an authorization for a zero balance.  Then when the items are added, the check-out would be called next.  The application would "assume" that the authorization was done after the items were added and will allow the checkout.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 56 -->
<!--[Title 1]-->
# Discovering Logic Flaws


<!--[Content Placeholder 2]-->
- Discovering logic flaws is a manual process
- Most tools can't examine logic
	- They test functionality
- This requires the tester to find the flaws
	- Mapping the application is crucial for this discovery step
- These types of flaws are more difficult to find
- Typically even harder to fix

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Logic flaws are typically not found via automated tools.  This is because the tools are not designed to perform logic tests, they are designed to exercise functionality and find flaws that exist within that functionality.  To find the logic flaw, the tool would need to be able to evaluate the success of the attack.  For example, the flaw in the shopping cart discussed previously, the tool would need to understand that it was testing a shopping cart and would also need to be able to figure out where to detect that the transaction had succeeded.  

While it is harder for us to find these flaws, it is typically even more difficult to fix them.  This is because the logic of an application is usually integral to the architecture and changing that has a greater impact.  Because of this, as testers, we need to look for recommendations that can lower the risk of the attack.  Using the shopping cart example again, one recommendation may be to implement a work-flow that validates orders against billing totals before shipping.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 57 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	- *** Logic Attack Exercise ***
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This exercise will target a logic attack in a transaction.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 58 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- ***API Attacks***
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will explore API attacks against AJAX applications.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 59 -->
<!--[Rectangle 2]-->
API Attacks

<!--[Rectangle 3]-->
- AJAX lends itself to complex frameworks
	- There is even an entire market of pre-built frameworks
- To make design simpler, they make use of common files
	- Common within an application
	- Functions included on all pages
- Keep in mind that non-AJAX application can also make use of API files
- These files take multiple forms

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Another problem with AJAX is the complexity of the application.  Commonly, the developers will include multiple functions in a single JavaScript file.  While this can, and does happen in "normal" applications, it is wider spread in AJAX applications.  

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 60 -->
<!--[Title 1]-->
# API files


<!--[Content Placeholder 2]-->
- The most commonly considered files are JavaScript files
	- Included across the application
- These files contain functions used by the application
	- Business logic and technical functionality
- By examining these files, we are able to find features we do not have access too
	- Assists us in building malicious requests

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This allows a tester to download the files and look for functions that the application isn't using on this particular page and call them directly.  This is similar to the logic attack, except it uses functionality that shouldn't have been exposed.  

An example of this that I have used before is when the developer included functions used by admin pages in the js files.  I wasn't able to access the actual admin pages but was able to call the JavaScript functions directly.  In this application I was able to add users to the system and then log in as them.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 61 -->
<!--[Title 1]-->
# Third-party APIs


<!--[Content Placeholder 2]-->
- Many sites use third-party libraries
- Some examples 
	- jQuery
	- Google Web Toolkit
- These libraries provide various functions to the site
	- Everything from aesthetics to business functionality
- The tester can identify these during mapping
	- These libraries can bring their own issues
- Scripts can be built or used to parse the libraries
	- GWTEnum by Gotham Digital Science is one example
	- http://www.gdssecurity.com

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
During our testing we often find libraries from third party sites.  These libraries provide many different functions and are so common because they provide developers with prebuilt capabilities.  During our mapping phase we should find these and are able to identify them either from comments or titles within the files.  By identifying these libraries, we can find out many things about the application.  For example, libraries have specific uses so we can know some of the purposes of the site based on the library.  Also the libraries may bring their own weaknesses to the application.


<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 62 -->
<!--[Title 1]-->
# Discovering API Files


<!--[Content Placeholder 2]-->
- Most of these files should have been found during the mapping phase
- Spidering the site should detect them
	- Look for SRC attributes
- One issue is when they appear on pre-authentication pages
- We must parse them to find vulnerable or interesting functions
	- Look for any functions that initiate or process HTTP requests (XMLHttpRequest)

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Most of the API files should be  found during spidering.    Looking through the application map, we should be able to see the .js files that are loaded by the various pages.

We just need to parse them and examine the code during this phase.  We would look for interesting functions such as any XMLHttpRequest calls.  We can also find various functions that load data from elsewhere or reference "sensitive" functionality such as administrative actions.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 63 -->
<!--[Title 1]-->
# Exploiting API Flaws


<!--[Content Placeholder 2]-->
- API exploitation takes many forms
- These are based on what the API exposes
- We may be able to call functions without authentication
	- Recreating what the code would have done
- We may be able to gather information for further exploits
	- Filtering code evaluated for weaknesses

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
API exploitation is another manual process.  We can do many different things with this information but what that is depends on the flaw that is exposed by the API.

For example, if the API discloses a set of functions that are for the admin, then we can create a request that attempts to exercise that functionality.  

We also can gather information useful in other attacks.  For example, we could find filtering code that attempts to prevent attack.  By examining that code, we may find weaknesses that would expose the application further along.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 64 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	- *** Data Binding Attacks***
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next section will cover the data binding attacks that are possible against AJAX applications.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 65 -->
<!--[Rectangle 2]-->
Data Attacks

<!--[Rectangle 3]-->
- The business logic is now on the client
- This means the client must receive more data
- Due to this change, most developers send more data to the client than necessary
	- Don't want to duplicate filtering code
- Attackers can focus on this data delivery

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Since AJAX application shine in data heavy features, the data becomes even more available to an attacker.  The web services being called by the application will return the data to the application.  Since this application mainly runs within the client system, this data becomes available to the attacker.  Many services return large amounts of data and use the client code to filter it out.  

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 66 -->
<!--[Title 1]-->
# Data Formats


<!--[Content Placeholder 2]-->
- AJAX applications can make use of data in any format
	- Decided by the developer
- The two most common are XML and JSON
- Both require some type of parsing client side
	- JSON can just be eval'ed but this has security issues

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
AJAX can use any format the developer decides to use in passing data.  For example, the developer could just have a fixed-width string passed to the client-side code.  But typically AJAX uses one of two options.  

The first option, and the one AJAX has in its name, is XML.  XML is a tag based format and is quite common.  But it is heavier than most other formats.

The second option is JSON.  We will explore JSON in more detail on the next series of slides.

Both of these formats need to be parsed on the client.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 67 -->
<!--[Rectangle 2]-->
JSON

<!--[Rectangle 3]-->
- JSON is the JavaScript Object Notation
- It is a light-weight data interchange format
	- Both requests and responses use this format
- The client side JavaScript then loads the JSON data into memory
	- Typically with an eval() call or a JSON parser

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The JavaScript Object Notation is commonly used to hold the data.  Both the request and the response gets stored in the JSON object, which can be thought of as an array.  

In the response side of the application, the tester is able to examine the object for any extraneous data that is of interest.  While in the request side, the tester is able to inject any of the typical attacks, such as SQL injection or XSS and determine how the application reacts to the unexpected items.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 68 -->
<!--[Title 1]-->
# JSON Format


<!--[Content Placeholder 2]-->
- Basically an array of arrays
- 
	**{"records": **
	**	{"id" : "1","name" : "Brenna","field1" : "11"},**
	**	{"id" : "2", "name" : "Sarah", "field1" : "7"},**
	**	{"id" : "3", "name" : "Denise", "field1" : "****43"},**
	**	{"id" : "4", "name" : "Kevin", "field1" : "40"}**
	**}**
- This is a simple response to a request for data
	- Parsed on the client

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The JSON format is basically an array.  It can contain other arrays, all that build into a single record set.  Both the requests and responses use this format.  As a tester, we need to be able to evaluate the objects we find within the context of the request or response.

For example, we can guess that the first column here is probably an identifier where the second is a first name.  The third column would need more context to ensure we knew what it represented.  (But I am sure my wife would be upset to see her third column being made public ? )

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 69 -->
<!--[Title 1]-->
# Exploiting JSON


<!--[Content Placeholder 2]-->
- Exploiting JSON takes one of two forms usually
- Information disclosure is the easiest to find
	- Typically discoverable via browsing through a proxy
- JSON is also one of the inputs we must test for injection flaws
	- It gets overlooked quite often due to its complex looks
- Let's explore these two ideas

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Exploiting JSON can take two different formats.  Information disclosure is the easiest to find during our mapping of the application.  The thing we must remember is that JSON is one of the injection points for our testing. 

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 70 -->
<!--[Title 1]-->
# JSON Information Disclosure


<!--[Content Placeholder 2]-->
- JSON is used to send data
- Most developers send more data than necessary
	- Some applications actually send complete record sets
	- Client code parses and displays what's needed
- SQL error messages are sent to the client in some cases
	- Client code parses and displays an application error message instead

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Since JSON is used to send data to the client logic, and most developers do not want to parse the record set on the server and then again on the client, more data than necessary is usually sent to the client.  We may even get entire record sets sent down that are parsed to the single record displayed by client logic.

We have seen many applications that will actually return the full database error to the client and then the client will filter it out.  From the screen it looks like you would have to go through the effort of performing a blind SQL attack, when in actuality all of the information is available in an interception tool.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 71 -->
<!--[Title 1]-->
# JSON Injection


<!--[Content Placeholder 2]-->
- Focus on the requests
- Intercept them and insert attack strings
	- Any attacks are useful
	- SQL injection and XSS are most common
- Client or server code can be targeted
- Remember to look in the interception proxy for the results
	- They may not be displayed on the page

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
To perform JSON injection we just need to focus on the requests.  We can intercept them with tools we have discussed and inject whatever attack we would like to attempt.  SQL injection and XSS are commonly successful against these types of applications.

Keep in mind that while we are focusing on using the JSON request as an injection point, it also has problems with code injection.  To find this, we need to find where we can control the data that is returned as part of the JSON response.  For example, If we could set our name it a snippet of JavaScript, when this is returned through the JSON response, this code could be executed.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 72 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	- *** AJAX Fuzzing Exercise***
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will explore RatProxy.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 73 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  ***RatProxy***
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will explore RatProxy.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 74 -->
<!--[Title 1]-->
# RatProxy


<!--[Content Placeholder 2]-->
- RatProxy is a mostly passive scanner
	- Can be instructed to actively scan based on traffic
- Released by Michal "lcamtuf" Zalewski
- http://code.google.com/p/ratproxy/
- Runs on Linux, Mac and Windows
- Can be chained with other
	- Different tools have different features
- Decompiles Flash objects
	- Actionscript 2.0

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Ratproxy is an automated scanner that acts mainly as a passive proxy.  When launched, unlike active scanners, ratproxy simply watches the traffic, unless directed otherwise.  The tester configures their browser to use ratproxy as a proxy server and then browses the web site.  The result of what it sees is saved into a file, specified on the command line.  Ratproxy ships with a shell script that reads this file and generates an HTML report.

Ratproxy does perform some active attacks during usage and it also decompiles any flash objects it sees.  These files are then evaluated for issues.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 75 -->
<!--[Title 1]-->
# Running RatProxy


<!--[Content Placeholder 2]-->
- Many options available
	- Passive and/or active scanning
	- Specify the target domain
	- A log directory which will contain the traces
	- A log file which will be used to generate the report
- Use the application through it normally
	- Do not launch a vulnerability scanner
	- It confuses RatProxy
		- This is because of the odd requests scanners make

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
RatProxy has a large number of options.  Some of the more important ones right now are if we want it to only passively scan the site or would we like it to actively attempt to break things as we browse through it.  It requires us to specify the domain and two log items.  The first is the log directory where it will store its trace files and the second is the log file which is used to generate the report.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 76 -->
<!--[Title 1]-->
# Report Screenshot


<!--[Content Placeholder 2]-->
- The report is an HTML document
- Uses various techniques to allow us to hide or view different sections
- Groups vulnerable requests
- Provides risk level
	- Based on its opinion
- Shows if the request requires authentication

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As you can see in the screenshot above, ratproxy generates a very nicely detailed report.  While I would not recommend using this report directly in the final report, it definitely helps the tester know where issues are and places that need to be explored more.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 77 -->
<!--[Title 1]-->
# Examining the Log Directory


<!--[Content Placeholder 2]-->
- If the log directory is specified
- Traces of the requests and response will be saved
- These traces will be linked to from the report
- This allows us to evaluate what was asked for and received
- Manually verifying what RatProxy reports 

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
If we have provided RatProxy with a log directory, it will contain a number of files that are trace files.  These are used within the reporting and to provide information about each item found.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 78 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	- *** RatProxy Exercise***
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover ratproxy and its usage.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 79 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
- *** Automated Web Application  
   Scanners***
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next few sections will cover some of the automated scanners we use.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 80 -->
<!--[Rectangle 35]-->

<!--[Title 1]-->
# Web App Vulnerability Scanners


<!--[Content Placeholder 2]-->
- Web app vulnerability scanners are different from scanners like Nessus
	- Nessus uses a series of plug-ins and send traffic to a machine to determine if it is vulnerable, but the plug-ins, for the most part, do not change what they do based on the response
- Web scanners interact with the site, through spidering or proxies
- This interaction actually changes the way the plug-ins send traffic
- We will be exploring some of the most popular scanners tool collections out there
	- w3af
	- Skipfish
	- WebSecurify

<!--[Text Box 13]-->
**Pen Tester**

<!--[Text Box 13]-->
**Target  
Web Server**

<!--[Object 3]-->

<!--[Rectangle 20]-->

<!--[Group 21]-->

<!--[Object 2]-->

<!--[Straight Arrow Connector 42]-->

<!--[Straight Arrow Connector 46]-->

<!--[Straight Arrow Connector 48]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Web application scanners are quite different from vulnerability scanners many of us are familiar with.  Scanner such as Nessus use plug-ins just the same as w3af does, but these plug-ins are different in how they deal with their function.  Vulnerability scanners typically send the same type of traffic no matter the situation, because they do not need to adjust since one FTP service behaves the same as another.  In web application scanners, the plug-ins will actually change the requests made based on what the scanner has seen in the application.  For example, a web form submits different parameters and the application may also set various cookies.  The web scanner, such as w3af take this into account.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 81 -->
<!--[Title 1]-->
# Choosing Plug-ins


<!--[Content Placeholder 2]-->
- Automated tools require multiple scans of the target
- Selecting all the plug-ins at once is a bad idea
	- Causes crashes due to resource limits
	- Can overwhelm the tools and the tester with information
- Each scan should use similar or grouped plug-ins
- For example, each scan below:
	1. Spider and Information Gathering Types
	2. Spider, SQL Injection, File Include and OS Command Injection
	3. Spider, XSS and CSRF
	4. Spider and plug-ins based on previous three scans

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Automated tools require us to scan a site multiple times to completely test it.  This is because selecting all of the available plug-ins within a tool causes problems.  For example, the tool may crash due to resource issues or will perform badly due to the amount of stuff it has to do.

So one of the questions asked often is how do we go about choosing plug-ins for our scans.  We tend to try and group the plug-ins based on some type of similarity between the plug-ins.  As shown on the slide, this can be done by grouping the type of attack.  For example, start with information gathering types and then move to plug-ins that run some type of command or action on the server.  After they run, try running the XSS and CSRF plug-ins as they are a related type of attack.  Finally, we tend to scan a final time and select plug-ins based on the results from the previous three scans.  This tends to have repeat plug-ins configured differently.

Note that because of the limitations of the tools, we must include a spider each time.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 82 -->
<!--[Title 1]-->
# Issues with Automated Scanners


<!--[Content Placeholder 2]-->
- Many issues can be found with automated scanners
	- These require the tester to understand in advance how they happen
- Scanners often have false positives
	- Findings that are not actually in the application
- False negatives are also an issue
	- Scanners will miss the vulnerability

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Automated scanners are not the be all end all, no matter what the vendor says.  ?  We have to understand how the scanner finds issues so that we can determine if they are correct.  We often find that the scanner will have false positives and negatives.  These are where it either reports a finding that doesn't really exist or even worse, misses one that does.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 83 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  ***SkipFish***
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The first scanner we will explore is Websecurify.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 84 -->
<!--[Title 1]-->
# Running Skipfish


<!--[Content Placeholder 2]-->
- Skipfish has been designed to provide a large number of options
	- While being simple to run
- Skipfish performs adaptive scanning and brute-forcing
	- Based on the dictionary selected and the responses from the site
- Skipfish performs a large number of scans
	- This can overwhelm a server!
	- Log files fill or memory is exhausted
- Skipfish can be set to analyze the content or just do brute forcing
- A great feature of Skipfish is that it will handle sites made up of multiple technologies
	- Portions of the site are PHP and others are ASPX 

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Skipfish has been designed to provide a large number of options while retaining the simplicity of a command line interface.  It will perform adaptive scanning where it analyzes the results and responses and makes decision based on whatever technology it finds, even if the site mixes different technologies!  It will also perform brute force attacks based on dictionary lists and the results from the site.  This means it will find /admin as well as index.aspx.old.

Keep in mind that while skipfish is fast, it also does many things, so testing can still take a while.  It also sends LOTS of requests so it can overwhelm a server.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 85 -->
<!--[Title 1]-->
# Skipfish Dictionary Modes


<!--[Content Placeholder 2]-->
- Skipfish uses a series of dictionaries
- These files provide a series of tests for Skipfish to use
	- Along the lines of brute forcing tests, not XSS discovery
- The use of these dictionaries is important to the success of the testing
- There are three basic modes to understand according to Michal
- No brute-force
	- This will perform only the regular testing of the site, missing non-linked files
- Minimal brute-force
	- For a quick test, this is an excellent start.  It looks for either fuzzed file name or extensions
- Normal brute-force
	- This performs all of the brute-force tests

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Skipfish comes with a series of predefined dictionaries for use during testing.  These are used to provide the dictionaries for brute-forcing the site.  While these appear simple on the surface, the misuse or misunderstanding of these files can actually cause you to miss issues or think the scan was more comprehensive than it really was.

According to Michal, and I agree, that while there are many options to understand within Skipfish, understanding three different brute-force modes will help make your testing better.  Those three modes are:
- 
- No brute-force
			- This will perform only the regular testing of the site, missing non-linked files
- Minimal brute-force
			- For a quick test, this is an excellent start.  It looks for either fuzzed file name or extensions
- Normal brute-force
			- This performs all of the brute-force tests

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 86 -->
<!--[Title 1]-->
# Skipfish Reporting


<!--[Content Placeholder 2]-->
- Skipfish generates a report when its finished
	- Or if the scan is cancelled
- This report is an HTML file
	- It includes findings as well as informational data
- It also includes traces of requests and responses

<!--[Picture 1]-->

<!--[Picture 2]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The reporting within skipfish is excellent.  Once the report is finished, skipfish generates a report into the output directory specified on the command line.  This report includes both the findings and information related to the test and the site being tested.  One of the nice features of the report is that it includes the full request and response skipfish sent and received. 

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 87 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	- *** SkipFish Exercise***
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise we will explore skipfish against various targets.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 88 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  ***w3af***
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now let's talk about one of the most functional open source tools available today.  W3af is a python application that we use on practically every penetration test we perform.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 89 -->
<!--[Rectangle 2]-->
Web Application Attack   
and Audit Framework

<!--[Rectangle 3]-->
- w3af is an open source web application scanner
- w3af is available at http://w3af.sourceforge.net 
	- Also included in the SamuraiWTF (more on that later)
- The project lead is Andres Riancho but a large number of developers have contributed patches and features
- It is written in python and has both a GUI and a command-terminal console interface
	- The GUI is simpler to use while the console is designed to provide more control of the scan
- w3af is designed to perform the spidering part of mapping, all of the server-side vulnerability discovery and exploitation
	- It bundles multiple tools such as sqlmap and BeEF to accomplish all of this
	- These are built into w3af as exploit modules

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
W3af is an open source application that is written in Python.  Andres Riancho is the current project lead.  It is a framework that allows developers and testers to write plug-ins that work together to perform the tests needed.  

Currently it has a console interface, similar to Metasploit, and a GUI using GTK.  This application runs on almost every platform.  The GUI is simpler to use, but the console provides more control of the scan.  w3af performs all of the steps involved in the application test.  This includes exploitation using bundled tools such as BeEF and SQLMap.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 90 -->
<!--[Picture 6]-->

<!--[Rectangle 7]-->
The w3af GUI

<!--[Rectangle 1027]-->
- The w3af GUI is designed to be as simple as possible
- We are able to build various profiles that allow us to save specific scan configurations
	- We build various scan profiles that include different test types, then when starting a penetration test, we put the target URL into the profile
	- This provides standard test schemes across pen-tests
- The target URL is the starting point of any scan
- A tester can choose entire categories or expand categories to select individual plug-ins
	- We recommend the latter because it provides the tester with greater control
	- It also allows us to decide if we want to use the experimental plug-ins in a category

<!--[TextBox 3]-->
Profiles

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Categories of scanning plug ins

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Output configuration

<!--[Left Arrow 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The GUI is designed to be simple to use while providing all we need to perform an application test.  w3af uses the concept of a profile to control what goes into a scan.  We commonly build multiple profiles that include different plug-ins and tests and save them for later use. 

The target URL is the starting point for the test.  Keep in mind that it requires an entire URL including the protocol.  We then select each plug-in we would like to run.  If the plug-in requires configuration, the options will be displayed on the right.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 91 -->
<!--[Rectangle 2]-->
The w3af Console

<!--[Rectangle 1027]-->
- On the right is a session running within the w3af console
	- It reminds some pen testers of the Metasploit console
- As we move through the system, the prompt changes to signify what area of the scan configuration we are in
- We are able to select various plug-ins and set their configuration
	- Output is considered a plug-in
		- Text File
		- Console
		- HTML File

<!--[Picture 1]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
On this screen we see the console version of w3af.  This console is very reminiscent of the Metasploit console and is used in the same way.  The console provides a pseudo-shell.  As we type in commands and select sections, the prompt will change to reflect where we are currently.  

A simple scan would look like:

$ **./w3af_console**
w3af>>> **plugins**
w3af/plugins>>> **output console,textFile**
w3af/plugins>>> **output config textFile**
w3af/plugins/output/config:textFile>>> **set fileName scan.txt **
w3af/plugins>>> **discovery allowedMethods**
w3af/plugins>>> **audit osCommanding**
w3af/plugins>>> **back**
w3af>>> **target**
w3af/config>>> **set target http://www.PEWAPT.org**
w3af/config>>> **back **
w3af>>> **start**


<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 92 -->
<!--[Title 1]-->
# w3af Scripting


<!--[Content Placeholder 2]-->
- One of the powers of the console version is its ability to be used in a script
- Simply enter each command into a file as we would in the console
	- For example:  
w3af/plugins>>> **discovery serverHeader**  
Would be **discovery serverHeader**** **in the script file****
- This file is then loaded in the command line of the console
	$ **w3af_console -s filename**
- We typically have a series of files that call different plug-ins and configurations
	- We then iterate through them using a script

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The console interface to w3af also supports scripting.  We are able to put all of the commands and options we would enter in the console into a text file.  We then load this file using the  -s option to  w3af_console.  w3af then reads each line, which contains one command, and processes them.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 93 -->
<!--[Rectangle 2]-->
w3af Discovery Plug-ins

<!--[Rectangle 3]-->
- There are a variety of plug-ins available within w3af
- These plug-ins are python scripts that use the w3af framework
- Plug-ins get updated quite often, so check for new ones
- Discovery plug-ins are used to find information regarding the application
	- This is different from the discovery step in our methodology
	- w3af contains a number of plug-ins that are designed to gather information
	- Spidering is selected within this set of plug-ins
- Some example discovery plug-ins are:
	- Robots Reader
		- Reads and reports on the robots.txt file
	- Detect Transparent Proxy
		- Uses TRACE method to find proxies
	- Google Spider
		- Spiders the target using content from Google cache

- 

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
w3af divides the plug-ins up in different categories.  The first is discovery.  This is different than the discovery step in our test.  Discovery plug-ins are used to gather information about the application and the server running it.  They cover both the recon and mapping steps in our methodology. 

Discovery plug-ins do various things such as spider the web site, both by requesting the page and using Google.  They also have features such as reading the robots.txt file and detecting transparent proxies.

The data found here is used by the other plug-ins.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 94 -->
<!--[Title 1]-->
# w3af Evasion Plug-ins


<!--[Content Placeholder 2]-->
- Evasion plug-ins are used in combination with any plug-in that sends traffic to the site
	- They perform various changes to the request to attempt to evade detection or prevention techniques
	- As testers, our main focus here is on evading prevention techniques
- Some examples are:
	- Modification that bypass typical mod_security installations
	- Adding self-referential directories to the URL
		- http://www.PEWAPT.org/./cgi-bin/./script.pl
	- Using hex encoding
	- Changing the case of letters randomly

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Evasion plug-ins are used in combination with the other plug-ins.  They change the way that requests are made.  For example, there is an evasion plug-in that encodes parts of the request.  These evasion techniques are used to bypass infrastructure items such as web app firewalls and filtering logic within the application or server.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 95 -->
<!--[Rectangle 2]-->
w3af Audit Plug-ins

<!--[Rectangle 3]-->
- Audit plug-ins are used to find various flaws
	- Audit plug-ins directly map to the discovery phase in our methodology
	- Tries to find flaws such as 
		- XSS
		- SQL injection
		- Response splitting
	- These plug-ins build from the information gathered using the discovery plug-ins
	- Some examples of audit plug-ins are:
		- sslCertificate
			- Finds issues with SSL configurations
		- unSSL
			- Determines if SSL content is available via HTTP
		- osCommanding
			- Attempts to find command injection flaws

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Audit plug-ins correspond to the discovery step in our methodology.  This category of plug-ins attempts to find the various flaws in an application that we can exploit for further access or data.  There are discovery plug-ins that cover every major type of web application flaw including XSS, SQL injection and CSRF.  These plug-ins feed data to the exploitation plug-ins we will discuss in a bit.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 96 -->
<!--[Rectangle 2]-->
w3af Grep Plug-ins

<!--[Rectangle 3]-->
- The next type of plug-ins we are discussing are grep or search plug-ins
	- Names grep from the UNIX command
- These plug-ins are used to find items of interest in the results from all of the other requests
	- Each plug-in request results in some form of response
	- These search those responses
- The results of grep plug-ins also act as input to other plug-ins
	- getMails will be used in the brute force attempts
- Some examples of grep plug-ins are:
	- Path disclosure
	- Code being disclosed
	- AJAX code
	- E-mail addresses
	- w3af can even determine the language used in the site

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Grep plug-ins are used to search for items of interest in the responses from the web application.  For example, we can ask w3af to find signs of code or paths being disclosed.  We can also gather e-mail addresses and AJAX code snippets being used in the application.  All of this information is then available to other plug-ins.  For example the getMails plug-in will feed the brute force plug-ins.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 97 -->
<!--[Title 1]-->
# w3af Brute Force Plug-ins


<!--[Content Placeholder 2]-->
- Brute Force plug-ins are used to find credentials for the site
	- W3af is able to attack Basic authentication and forms-based authentication
	- The brute forcing can use any e-mail addresses found from other plug-ins
- The brute force plug-ins base can use information gathered by the other plug-ins
	- E-mails gathered can be used as usernames
	- Words from the site can be used as password
- Currently the brute force plug-ins are available for:
	- Forms based authentication
	- HTTP Basic authentication

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The brute force plug-ins attempt to guess authentication credentials for the web application.  Currently there are two plug-ins in this category, basic and forms.  They will use data gathered from the other plug-ins to guess credentials, such as e-mail addresses for user names and words used in the site as passwords.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 98 -->
<!--[Rectangle 2]-->
Running w3af

<!--[Rectangle 3]-->
- First, enter the URL to start the test from
	- One URL is the   
limit
- Create a Profile
	- Select which   
plug-ins to use
	- Select output
	- Make sure that in the   
configuration of the   
spider, you limit it to   
the target
- Press Start

<!--[Picture 1]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
To start a scan, the tester needs to enter in a URL.  As we discussed earlier, this URL can be as complex as needed.  You can then either select an existing profile that has certain plug-ins selected, or create a specific profile for this test.  When I perform a scan, I personally like to create a profile for this specific scan.  Even if it is similar or the same as another profile, it allows me to ensure I keep things separate.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 99 -->
<!--[Rectangle 2]-->
w3af Results

<!--[Rectangle 3]-->
- Any potential vulnerabilities are listed here for review
- The full response content is captured and viewable for detailed analysis
	- Raw
	- Rendered
- The results can also be searched for interesting strings
	- Using the "Response Navigator" tab

<!--[Picture 2]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
After the scan runs, the results will show up on this screen.  The tester is able to see all of the requests that were considered "interesting".  Both the request from the client and the response from the server are visible.  This allows the tester to verify the results.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 100 -->
<!--[Rectangle 2]-->
w3af Exploitation

<!--[Rectangle 3]-->
- After the scan, w3af offers functionality to exploit discovered flaws
	- Exploits are available based on results of the scan
- Depending on the discovered flaw, these features can be used  to.
	- .get command shell access of target web server
	- .hook browsers via XSS flaws in the server
	- .interact with a command shell on a database server using sqlmap
	- Numerous other possibilities
- w3af thus partially automates the last step of our testing methodology
	- More regarding this in PEWAPT101.5

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
w3af also handles the exploitation phase of the test.  This will be covered more later in class, but we wanted to mention that it was available within the same tool used for discovery.

w3af includes quite a few powerful exploitation options.  Most of these are focused on providing a shell either on the web server itself or on database servers behind it.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 101 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	- *** w3af Exercise***

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise we will explore the various pieces of w3af.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 102 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View, Pen-Testing  
& Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- <span style="text-decoration: underline;">***Server-Side Vuln***</span>***   
***<span style="text-decoration: underline;">***Discovery Cont.***</span>
- Exploitation
- Capture the Flag

<!--[Rectangle 1043]-->
-  Cross-Site Scripting (XSS)  
-  Cross-Site Scripting Exercise
-  Cross-Site Scripting Discovery
-  Persistent XSS Exercise
-  Cross-Site Request Forgery (CSRF)
-  Session Flaws
-  Session Fixation
-  AJAX
	-  Logic Attacks
	-  Logic Attack Exercise 
	- API Attacks
	-  Data Binding Attacks
	-  AJAX Fuzzing Exercise
	-  RatProxy
	-  RatProxy Exercise
-  Automated Web Application  
   Scanners
	-  SkipFish
	-  SkipFish Exercise
	-  w3af
	-  w3af Exercise

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
And now to wrap up today.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 103 -->
<!--[Title 1]-->
# Conclusions


<!--[Content Placeholder 2]-->
- We have now complete discovery
- Combine server-side and client-side to perform a more thorough test
- We now have all the information needed for the next phase

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now we have completed both sides of the discovery phase.  This allows us to have prepared for the next step.  We have also reviewed PHP and determined how it can fit into our testing.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 104 -->
<!--[Rectangle 2]-->
Summary

<!--[Rectangle 3]-->
- Completed the first 3 steps in the methodology
- Tomorrow we take on exploitation
- 
- Thank you!

Note:
<!--[Text Box 3]-->
We have completed step 3 and now just have to finish with exploitation.

Thank you!

<!--[Rectangle 4]-->

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

